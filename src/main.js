window.app = {
    assets: [
        {"name": "imgNumbers",          "path": "assets/sprites/numbers.json"},
        {"name": "winTexts",            "path": "assets/sprites/win_title.json"},

        {"name": "imgBtnBg",            "path": "assets/images/buttons/bg.svg"},
        {"name": "imgBtnBgSpin",        "path": "assets/images/buttons/bgSpin.svg"},
        {"name": "imgBtnAuto",          "path": "assets/images/buttons/auto.svg"},
        {"name": "imgBtnArrows",        "path": "assets/images/buttons/arrows.svg"},
        {"name": "imgBtnBurger",        "path": "assets/images/buttons/burger.svg"},
        {"name": "imgBtnCross",         "path": "assets/images/buttons/cross.svg"},
        {"name": "imgBtnCrossSmall",    "path": "assets/images/buttons/crossSmall.svg"},
        {"name": "imgBtnHelp",          "path": "assets/images/buttons/help.svg"},
        {"name": "imgBtnMoney",         "path": "assets/images/buttons/money.svg"},
        {"name": "imgBtnRect",          "path": "assets/images/buttons/rect.svg"},
        {"name": "imgBtnSpeaker",       "path": "assets/images/buttons/speaker.svg"},
        {"name": "imgBtnTriangle",      "path": "assets/images/buttons/triangle.svg"},
        {"name": "imgBtnTriangleSmall", "path": "assets/images/buttons/triangleSmall.svg"},
        {"name": "imgBtnWave",          "path": "assets/images/buttons/wave.svg"},

        {"name": "imgLangAz",           "path": "assets/images/lang/az.png"},
        {"name": "imgLangBn",           "path": "assets/images/lang/bn.png"},
        {"name": "imgLangDe",           "path": "assets/images/lang/de.png"},
        {"name": "imgLangEl",           "path": "assets/images/lang/el.png"},
        {"name": "imgLangEs",           "path": "assets/images/lang/es.png"},
        {"name": "imgLangFr",           "path": "assets/images/lang/fr.png"},
        {"name": "imgLangEn",           "path": "assets/images/lang/gb.png"},
        {"name": "imgLangHi",           "path": "assets/images/lang/hi.png"},
        {"name": "imgLangMr",           "path": "assets/images/lang/hi.png"},
        {"name": "imgLangTe",           "path": "assets/images/lang/hi.png"},
        {"name": "imgLangId",           "path": "assets/images/lang/id.png"},
        {"name": "imgLangIt",           "path": "assets/images/lang/it.png"},
        {"name": "imgLangKk",           "path": "assets/images/lang/kk.png"},
        {"name": "imgLangKo",           "path": "assets/images/lang/ko.png"},
        {"name": "imgLangKy",           "path": "assets/images/lang/ky.png"},
        {"name": "imgLangLt",           "path": "assets/images/lang/lt.png"},
        {"name": "imgLangPl",           "path": "assets/images/lang/pl.png"},
        {"name": "imgLangPt",           "path": "assets/images/lang/pt.png"},
        {"name": "imgLangRu",           "path": "assets/images/lang/ru.png"},
        {"name": "imgLangSw",           "path": "assets/images/lang/sw.png"},
        {"name": "imgLangTg",           "path": "assets/images/lang/tg.png"},
        {"name": "imgLangTh",           "path": "assets/images/lang/th.png"},
        {"name": "imgLangTl",           "path": "assets/images/lang/tl.png"},
        {"name": "imgLangTr",           "path": "assets/images/lang/tr.png"},
        {"name": "imgLangUk",           "path": "assets/images/lang/uk.png"},
        {"name": "imgLangUz",           "path": "assets/images/lang/uz.png"},
        {"name": "imgLangVi",           "path": "assets/images/lang/vi.png"},
        {"name": "imgLangZh",           "path": "assets/images/lang/zh.png"},

        {"name": "imgJp1",              "path": "assets/images/img1.webp"},
        {"name": "imgJp2",              "path": "assets/images/img2.webp"},
        {"name": "imgJp3",              "path": "assets/images/img3.webp"},
        {"name": "imgJp4",              "path": "assets/images/img4.webp"},

        {"name": "imgBgMain",           "path": "assets/images/bgMain.png"},









        //{ "name": "sfxMap",             "path": "assets/sound/sprite.json" },
        //{ "name": "sfxMain",            "path": "assets/sound/mainSounds.mp3"},

        {"name": "animSymbolBoots",     "path": "assets/sprites/0-boots.json"},
        {"name": "animSymbolPick",      "path": "assets/sprites/1-pick.json"},
        {"name": "animSymbolHelmet",    "path": "assets/sprites/2-helmet.json"},
        {"name": "animSymbolTnt",       "path": "assets/sprites/3-tnt.json"},
        {"name": "animSymbolGold",      "path": "assets/sprites/4-gold.json"},
        {"name": "animSymbolCart",      "path": "assets/sprites/5-cart.json"},
        {"name": "animSymbolGnome",     "path": "assets/sprites/6-wild.json"},
        {"name": "animSymbolScatter",   "path": "assets/sprites/7-scatter.json"}

    ],
    lines_colors: [
        ['#ffc063', '#faf17a'], //scatter
        ['#6c58ad','#806cc1'],
        ['#6d4b0f','#815f23'],
        ['#c2949d','#d6a8b1'],
        ['#d24282','#e65696'],
        ['#c5de49','#d9f25d'],
        ['#f60697','#e21aab'],
        ['#4944eb','#5d58ff'],
        ['#0f4fb5','#2363c9'],
        ['#bd0213','#d11627'],
        ['#861c13','#9a3027'],
        ['#1d43a1','#3157b5'],
        ['#b75bb5','#cb6fc9'],
        ['#fc0284','#e81698'],
        ['#7e4b86','#925f9a'],
        ['#5bdaa7','#6feebb'],
        ['#45d032','#59e446'],
        ['#af6139','#c3754d'],
        ['#618970','#759d84'],
        ['#b546f2','#c95ade'],
        ['#7bd1a8','#8fe5bc'],
        ['#bc534c','#d06760'],
        ['#c8b683','#dcca97'],
        ['#3270fa','#4684e6'],
        ['#9bc465','#afd879'],
        ['#51ce9d','#65e2b1'],
        ['#10a9ca','#24bdde'],
        ['#53ae55','#67c269'],
        ['#0d9d6d','#21b181'],
        ['#240b78','#381f8c'],
        ['#f324a4','#df38b8'],
        ['#4e3ca3','#6250b7'],
        ['#34baca','#48cede'],
        ['#97a244','#abb658'],
        ['#9bbb79','#afcf8d'],
        ['#24d070','#38e484'],
        ['#feb5f2','#eac9de'],
        ['#dc0a27','#f01e3b'],
        ['#793f26','#8d533a'],
        ['#57c308','#6bd71c'],
        ['#482a15','#5c3e29'],
        ['#f2668e','#de7aa2'],
        ['#38b907','#4ccd1b'],
        ['#1f12de','#3326f2'],
        ['#ed6297','#d976ab'],
        ['#14046d','#281881'],
        ['#b99326','#cda73a'],
        ['#8bc247','#9fd65b'],
        ['#2e6390','#4277a4'],
        ['#e64db9','#fa61cd'],
        ['#a7bd5a','#bbd16e'],
        ['#feeaee','#eafeda'],
        ['#37c5d4','#4bd9e8'],
        ['#c5481a','#d95c2e'],
        ['#0cfb65','#20e779'],
        ['#02e5f0','#16f9dc'],
        ['#717394','#8587a8'],
        ['#005001','#146415'],
        ['#589977','#6cad8b'],
        ['#a8e58d','#bcf9a1'],
        ['#e0f9c8','#f4e5dc'],
        ['#43364d','#574a61'],
        ['#93aac9','#a7bedd'],
        ['#e7e823','#fbfc37'],
        ['#e9794f','#fd8d63'],
        ['#b3ef4d','#c7db61'],
        ['#6c48b6','#805cca'],
        ['#8d0e29','#a1223d'],
        ['#b3b3ee','#c7c7da'],
        ['#ce3960','#e24d74'],
        ['#27322c','#3b4640'],
        ['#6e47a1','#825bb5'],
        ['#c36256','#d7766a'],
        ['#51cc16','#65e02a'],
        ['#b11882','#c52c96'],
        ['#f2c1c9','#ded5dd'],
        ['#902718','#a43b2c'],
        ['#26b143','#3ac557'],
        ['#6a6e88','#7e829c'],
        ['#3c49fc','#505de8'],
        ['#d32125','#e73539'],
        ['#93d3e3','#a7e7f7'],
        ['#49d8b6','#5decca'],
        ['#5e0aaf','#721ec3'],
        ['#0d3527','#21493b'],
        ['#bdcaf9','#d1dee5'],
        ['#754a88','#895e9c'],
        ['#770176','#8b158a'],
        ['#0f249d','#2338b1'],
        ['#3c2032','#503446'],
        ['#0cdc3d','#20f051'],
        ['#f4f021','#e0dc35'],
        ['#e0ce32','#f4e246'],
        ['#438468','#57987c'],
        ['#ca320f','#de4623'],
        ['#ba303b','#ce444f'],
        ['#cf58f7','#e36ce3'],
        ['#8d47ea','#a15bfe'],
        ['#1405f3','#2819df'],
        ['#be7afa','#d28ee6'],
        ['#5e0783','#721b97'],
        ['#a36b14','#b77f28'],
        ['#74ac8d','#88c0a1'],
        ['#9b99c2','#afadd6'],
        ['#59653a','#6d794e'],
        ['#6fb7d6','#83cbea'],
        ['#63562c','#776a40'],
        ['#e097e7','#f4abfb'],
        ['#6dfee3','#81eaf7'],
        ['#b4fd24','#c8e938'],
        ['#35120a','#49261e'],
        ['#596fd5','#6d83e9'],
        ['#26ebb4','#3affc8'],
        ['#1c04f4','#3018e0'],
        ['#91731c','#a58730'],
        ['#e97378','#fd878c'],
        ['#f02893','#dc3ca7'],
        ['#d4bb08','#e8cf1c'],
        ['#2b9393','#3fa7a7'],
        ['#929974','#a6ad88'],
        ['#6e9516','#82a92a'],
        ['#c21a6b','#d62e7f'],
        ['#fc9de9','#e8b1fd'],
        ['#7df199','#91ddad'],
        ['#1d3d4b','#31515f'],
        ['#e780d9','#fb94ed'],
        ['#63fbba','#77e7ce'],
        ['#15c7b9','#29dbcd'],
        ['#0188c7','#159cdb'],
        ['#c9077c','#dd1b90'],
        ['#fec7b3','#eadbc7'],
        ['#3e6388','#52779c'],
        ['#33c825','#47dc39'],
        ['#09fb45','#1de759'],
        ['#0c8d95','#20a1a9'],
        ['#a6867b','#ba9a8f'],
        ['#aa4423','#be5837'],
        ['#7575d8','#8989ec'],
        ['#f91b69','#e52f7d'],
        ['#728ca1','#86a0b5'],
        ['#bf0769','#d31b7d'],
        ['#d33763','#e74b77'],
        ['#6a2292','#7e36a6'],
        ['#cf8a82','#e39e96'],
        ['#3b52fe','#4f66ea'],
        ['#868b17','#9a9f2b'],
        ['#a54122','#b95536'],
        ['#45a397','#59b7ab'],
        ['#b78264','#cb9678'],
        ['#9c72a7','#b086bb'],
        ['#140797','#281bab'],
        ['#60008f','#7414a3'],
        ['#e6b413','#fac827'],
        ['#fc6c75','#e88089'],
        ['#18b367','#2cc77b'],
        ['#efee8c','#dbdaa0'],
        ['#45dde3','#59f1f7'],
        ['#bb69c6','#cf7dda'],
        ['#b10cf2','#c520de'],
        ['#9d6e80','#b18294'],
        ['#a6bf8c','#bad3a0'],
        ['#3dfb5d','#51e771'],
        ['#bb7553','#cf8967'],
        ['#de2f3a','#f2434e'],
        ['#5db1c0','#71c5d4'],
        ['#8ed542','#a2e956'],
        ['#75e9b3','#89fdc7'],
        ['#0e6c74','#228088'],
        ['#0f5e9e','#2372b2'],
        ['#c3884a','#d79c5e'],
        ['#3bd3e6','#4fe7fa'],
        ['#02c156','#16d56a'],
        ['#7bb8e1','#8fccf5'],
        ['#ca8483','#de9897'],
        ['#0454be','#1868d2'],
        ['#9e775b','#b28b6f'],
        ['#2b5253','#3f6667'],
        ['#77b43d','#8bc851'],
        ['#f639dd','#e24df1'],
        ['#ec99af','#d8adc3'],
        ['#507852','#648c66'],
        ['#421767','#562b7b'],
        ['#0ae82f','#1efc43'],
        ['#80ce49','#94e25d'],
        ['#e96e2d','#fd8241'],
        ['#2faddc','#43c1f0'],
        ['#fd9080','#e9a494'],
        ['#ba00ec','#ce14d8'],
        ['#7aa5e8','#8eb9fc'],
        ['#0deb19','#21ff2d'],
        ['#d5ed76','#e9d98a'],
        ['#95ebab','#a9ffbf'],
        ['#eed41a','#dae82e'],
        ['#988a52','#ac9e66'],
        ['#941a4f','#a82e63'],
        ['#dee4f6','#f2f8e2'],
        ['#417e26','#55923a'],
        ['#ed825c','#d99670'],
        ['#f06521','#dc7935'],
        ['#3366da','#477aee'],
        ['#43511b','#57652f'],
        ['#f84ac9','#e45edd'],
        ['#fe7e8a','#ea929e'],
        ['#55a3ec','#69b7d8'],
        ['#8ab1e4','#9ec5f8'],
        ['#8b5782','#9f6b96'],
        ['#bd6a15','#d17e29'],
        ['#4918e4','#5d2cf8'],
        ['#c2f40f','#d6e023'],
        ['#bc4732','#d05b46'],
        ['#225581','#366995'],
        ['#030247','#17165b'],
        ['#7494cd','#88a8e1'],
        ['#51360e','#654a22'],
        ['#bf3bfe','#d34fea'],
        ['#794158','#8d556c'],
        ['#f90be6','#e51ffa'],
        ['#08a24a','#1cb65e'],
        ['#92711e','#a68532'],
        ['#71ccd7','#85e0eb'],
        ['#c4bf6f','#d8d383'],
        ['#2f64a7','#4378bb'],
        ['#e5f5b1','#f9e1c5'],
        ['#943433','#a84847'],
        ['#c75506','#db691a'],
        ['#19d8d1','#2dece5'],
        ['#5d4577','#71598b'],
        ['#9de26f','#b1f683'],
        ['#a80e3d','#bc2251'],
        ['#f48eaf','#e0a2c3'],
        ['#e4364c','#f84a60'],
        ['#c65810','#da6c24'],
        ['#e202ed','#f616d9'],
        ['#19db27','#2def3b'],
        ['#7612b3','#8a26c7'],
        ['#0711c2','#1b25d6'],
        ['#d0e5d1','#e4f9e5'],
        ['#812efb','#9542e7'],
        ['#dc4d5d','#f06171'],
        ['#636dc6','#7781da'],
        ['#f8d547','#e4e95b'],
        ['#d6a251','#eab665'],
        ['#335751','#476b65'],
        ['#f6e0a4','#e2f4b8']
    ],
    pixi: null,
    data: {
        "lineCoord": {
            "begin": 0,
            "0": 123,
            "1": 369,
            "2": 615,
            "3": 861,
            "4": 1107,
            "end": 1230
        }
    },
    game: {
        "lines": 243,
        "bet": 1,
        "spinTicker": null,
        "symbols": [
            [null, null, null, null, null],
            [null, null, null, null, null],
            [null, null, null, null, null]
        ],
        "winAnimation": false,
        "spinning": false,
        "speed": 1
    },
    texts: {},
    lang: "ru",
    buttons: {},
    autospin: {
        enabled: false
    },
    fingergrint: null,
    screens: {},
    modals: {},
    currentScreen: null,
    gameTime: 2500,
    sound: true,
    gameNameApi: "livefruits",
//    gameNameApi: "supabets",
    gameName: "Ultraminer",
    spinning: [false,false,false,false,false],
    symbolMap: {
        0: ["animSymbolBoots"],
        1: ["animSymbolPick"],
        2: ["animSymbolHelmet"],
        3: ["animSymbolTnt"],
        4: ["animSymbolGold"],
        5: ["animSymbolCart"],
        6: ["animSymbolScatter"],
        7: ["animSymbolGnome"]
    },
    winMap: {
        10: "big",
        20: "mega",
        30: "epic",
        40: "super",
    },
    gameWidth: 1230,
    gameHeight: 2460,
    minGameHeight: 2177,
    gameRoot: null,
    PROGRESS_W: 720,
    PROGRESS_H: 40,

    // старт всей игры
    async init() {
        // фиксированный логический размер игры
        this.pixi = new PIXI.Application();
        await this.pixi.init({
            backgroundAlpha: 0,
            width: window.innerWidth,
            height: window.innerHeight,
            autoDensity: true,
            resolution: window.devicePixelRatio || 1
        });

        document.getElementById('root').appendChild(this.pixi.canvas);

        // ресайз
        window.addEventListener('resize', () => this.resize());
        window.addEventListener('orientationchange', () => {
            setTimeout(() => this.resize(), 200);
        });

        this.game.speed = this.lsGet('game', 'speed', 1);
        this.lang = this.lsGet('data', 'lang', 'en');
        this.sound = this.lsGet('data', 'sound', true);
        this.game.lines = this.lsGet('game', 'lines', 1);
        this.game.bet = this.lsGet('game', 'bet', 1);

        this.gameRoot = new PIXI.Container();

        this.fingergrint = new Agtunique().get();
        console.log(this.fingergrint);

        await this.createScreens();

        await PIXI.Assets.load({
            alias: 'imgLogo',
            src: 'assets/images/logo.png'
        });

        await this.buildLoadingScreen();
        this.resize(false);
        await this.loadAssets();

/*
        const keys = Object.keys(this.langs).sort();
        console.log("Langs count:", keys.length);
        console.log("Langs keys:", keys);
*/

        this.screens.loading.visible = false;

        this.initFullscreen();

        await this.buildBg();
        await this.buildGameScreen();
        await this.buildBetsModal();
        await this.buildWinsModal();
        await this.buildAutoModal();
        await this.buildSettingsModal();
        //await this.buildHelpModal();
        this.resize();
        this.screens.game.visible = true;


        const ws = new WebSocket("wss://fertiso.xyz:2096/777");
        this.ws = ws;

        ws.onopen = () => {
            console.log("WebSocket connected");
        };

        ws.onmessage = (event) => {
            JSON.parse(event.data).data.forEach((v, i) => {
                this.jpText[i].text = Number(v).toFixed(2);
            });
        };

        ws.onerror = (err) => {
            console.error("WebSocket error", err);
        };

        ws.onclose = (event) => {
            console.log("WebSocket closed", event.code, event.reason);
        };

        this.cacheNumberFrames = (() => {
            const sheet = PIXI.Assets.get("imgNumbers"); // <= твой атлас
            const map = {};

            // Если это spritesheet PIXI v8
            if (sheet && sheet.textures) {
                for (let key in sheet.textures) {
                    map[key] = sheet.textures[key];
                }
            }

            return map;
        })();

        //this.initFullscreen();

        // Переход на экран игры (или другой)
        //this.showScreen('game');
        //this.openModal(this.modals.wins);


        //this.showScreen('loading');
    },

    // создаём экраны (контейнеры)
    createScreens() {
        //console.log("Create screens...");

        this.screens.loading = new PIXI.Container();
        this.screens.bg      = new PIXI.Container();
        this.screens.game    = new PIXI.Container();

        // Модальный слой
        this.screens.game.visible = false;
        this.screens.bg.visible = true;

        // добавляем в stage
        this.pixi.stage.addChild(
            this.screens.bg,
            this.gameRoot,
        );
        this.gameRoot.addChild(
            this.screens.loading,
            this.screens.game
        );
    },

    // переключение экранов
    showScreen(name) {
//        for (const s in this.screens) {
//            this.screens[s].visible = false;
//        }
        this.screens[name].visible = true;
        this.currentScreen = name;

        //console.log("Screen:", name);
    },

    hideScreen(name) {
//        for (const s in this.screens) {
//            this.screens[s].visible = false;
//        }
        this.screens[name].visible = false;
        //this.currentScreen = name;

        //console.log("Screen:", name);
    },

    buildLoadingScreen() {
        const screen = this.screens.loading;
        screen.removeChildren();

        const CARD_W = 800;
        const CARD_H = 280;

        // Лого
        const logo = new PIXI.Sprite(PIXI.Assets.get('imgLogo'));
        logo.anchor.set(0.5);
        logo.scale.set(0.6);
        screen.addChild(logo);

        // Карточка
        const card = new PIXI.Graphics();
        card.beginFill(0x222222, 0.85);
        card.drawRoundedRect(0, 0, CARD_W, CARD_H, 40);
        card.endFill();
        screen.addChild(card);

        // Текст
        this.loadingText = new PIXI.Text({
            text: "Launching Game... 0%",
            style: {
                fill: "#ffffff",
                fontSize: 40,
                fontWeight: "bold"
            }
        });
        screen.addChild(this.loadingText);

        // Прогрессбар фон
        const barBg = new PIXI.Graphics();
        barBg.beginFill(0x555555);
        barBg.drawRoundedRect(0, 0, 720, 40, 20);
        barBg.endFill();
        screen.addChild(barBg);

        // Активная часть
        this.progressBar = new PIXI.Graphics();
        screen.addChild(this.progressBar);

        // === ЦЕНТРОВКА ОТНОСИТЕЛЬНО gameRoot ===
        const cx = this.gameWidth  / 2 - CARD_W / 2;
        const cy = this.gameHeight / 2 - CARD_H / 2;

        card.x = cx;
        card.y = cy + 100;

        this.loadingText.x = cx + CARD_W / 2 - this.loadingText.width / 2;
        this.loadingText.y = cy + 150;

        barBg.x = cx + (CARD_W - 720) / 2;
        barBg.y = cy + 240;

        logo.x = cx + CARD_W / 2;
        logo.y = cy - 150;

        this.progressBar.x = barBg.x;
        this.progressBar.y = barBg.y;
    },

    async loadAssets() {
        //this.showScreen('loading');
        const assets = this.assets || [];
        const total = assets.length + 2;
        let loadedCount = 0;
        for (const item of assets) {
            PIXI.Assets.add({
                alias: item.name,
                src: item.path
            });
            await PIXI.Assets.load(item.name);
            loadedCount++;
            const percent = Math.floor((loadedCount / total) * 100);
            this.updateLoadingProgress(percent);
        }

        await this.apiStart();
        loadedCount++;
        this.updateLoadingProgress(Math.floor((loadedCount / total) * 100));

        await this.apiRestore();
        loadedCount++;
        this.updateLoadingProgress(Math.floor((loadedCount / total) * 100));

        // === Готово, прогресс 100% ===
        this.updateLoadingProgress(100);
    },

    updateLoadingProgress(percent) {
        this.loadingText.text = `Launching Game... ${percent}%`;

        const w = this.PROGRESS_W * (percent / 100);
        const h = this.PROGRESS_H;

        this.progressBar.clear();
        this.progressBar.beginFill(0xffffff);
        this.progressBar.drawRoundedRect(0, 0, w, h, h / 2);
        this.progressBar.endFill();
    },

    async buildBetsModal() {
        const screen = new PIXI.Container();
        screen.removeChildren();
        this.modals.bets = screen;
        this.gameRoot.addChild(screen);
        screen.visible = false;

        screen.eventMode = "static";
        screen.on("pointerdown", (e) => {
            e.stopPropagation();
        });

        const betsWindowContainer = new PIXI.Container();
        betsWindowContainer.x = 100;
        betsWindowContainer.y = 1000;

        const betsWindowBg = new PIXI.Graphics();
        betsWindowBg.roundRect(0, 0, 1080, 1000, 20)
            .fill({ color: 0x000000, alpha: 0.9 })
            .stroke({ width: 2, color: 0xffffff });

        betsWindowContainer.addChild(betsWindowBg);
        screen.addChild(betsWindowContainer);

        const padding = 15;
        const btnWidth = 245;
        const btnHeight = 100;

        const linesContainer = new PIXI.Container();
        linesContainer.x = 25;
        linesContainer.y = 25;

        const betsContainer = new PIXI.Container();
        betsContainer.x = 25;
        betsContainer.y = 300;

        betsWindowContainer.addChild(linesContainer);
        betsWindowContainer.addChild(betsContainer);

        const makeButton = (label, width, height, onClick, active = false) => {
            const btn = new PIXI.Container();
            btn.eventMode = "static";
            btn.cursor = active ? "default" : "pointer";

            const bg = new PIXI.Graphics();
            bg.roundRect(0, 0, width, height, 25)
                .fill({ color: active ? 0x5555aa : 0x333333 })
                .stroke({ width: 4, color: active ? 0xffffff : 0x777777 });
            btn.addChild(bg);

            const txt = new PIXI.Text({
                text: label,
                style: {
                    fill: active ? "#ffffaa" : "white",
                    fontSize: 44,
                    fontWeight: "bold"
                }
            });
            txt.x = (width - txt.width) / 2;
            txt.y = (height - txt.height) / 2;
            btn.addChild(txt);

            if (!active) {
                btn.on("pointerover", () => { bg.tint = 0x666666; });
                btn.on("pointerout", () => { bg.tint = 0xffffff; });
                btn.on("pointerdown", onClick);
            }

            return btn;
        };


        const lineKeys = Object.keys(this.data.bets);   // ["243", "244", ...]
        let selectedLines = null;

        const renderLines = () => {
            linesContainer.removeChildren();

            let x = 0;
            let y = 0;

            lineKeys.forEach((lineKey) => {
                const isActive = this.game.lines === parseInt(lineKey);

                const btn = makeButton(
                    `${lineKey} lines`,
                    btnWidth,
                    btnHeight,
                    () => {
                        //this.game.lines = parseInt(lineKey);
                        renderLines();           // обновляем выделение
                        renderBets(lineKey);     // обновляем список ставок
                    },
                    isActive
                );

                btn.x = x;
                btn.y = y;
                x += btnWidth + padding;
                if (x > 800) {
                    x = 0;
                    y += btnHeight + padding;
                }
                linesContainer.addChild(btn);
            });

            // Если при отрисовке уже есть активная линия - сразу рисуем ставки
            if (this.game.lines) {
                renderBets(String(this.game.lines));
            }
        };

        const renderBets = (lineKey) => {
            betsContainer.removeChildren();
            const betList = this.data.bets[lineKey];
            if (!betList) return;

            let x = 0;
            let y = 0;

            betList.forEach((betValue) => {
                const isActive = this.game.bet === betValue;

                const btn = makeButton(
                    `${betValue}`,
                    btnWidth,
                    btnHeight,
                    () => {
                        this.game.lines = lineKey;
                        this.game.bet = betValue;
                        renderBets(lineKey);  // обновляем выделение
                        this.data.betText.text = betValue;
                        this.data.linesText.text = lineKey;
                        this.closeModal(this.modals.bets);
                    },
                    isActive
                );

                btn.x = x;
                btn.y = y;
                x += btnWidth + padding;
                if (x > 800) {
                    x = 0;
                    y += btnHeight + padding;
                }
                betsContainer.addChild(btn);
            });
        };

        renderLines();
    },

    async buildWinsModal() {
        const screen = new PIXI.Container();
        screen.removeChildren();
        this.modals.wins = screen;
        screen.noBgClose = true;
        this.gameRoot.addChild(screen);
        screen.visible = false;

        screen.eventMode = "static";
        screen.on("pointerdown", (e) => {
            e.stopPropagation();
        });

        const cx = this.gameWidth/2;
        const cy = this.gameHeight/2;

        const screenWidth = 246*5;
        const screenHeight = 246*3;
        this.gameFieldWidth = screenWidth;
        this.gameFieldHeight = screenHeight;

        screen.x = 0;
        screen.y = 670;
        screen.width = screenWidth;
        screen.height = screenHeight;

        const screenBg = new PIXI.Graphics();
        screenBg.roundRect(0, 0, screenWidth, screenHeight, 15)
            .fill({ color: 0x000000, alpha: 0.3 })
            .stroke({ width: 2, color: 0xffffff });

        const winWindowContainer = new PIXI.Container();
        winWindowContainer.x = 0;
        winWindowContainer.y = 0;
        winWindowContainer.width = screenWidth;
        winWindowContainer.height = screenHeight;
        this.game.linesCanvas = winWindowContainer;
        screen.addChild(winWindowContainer);

        // === 4. Создание контейнера числа ===
        this.winNumber = new PIXI.Container();
        this.winNumber.x = screenWidth/2-100;
        this.winNumber.y = screenHeight/2-50;

        screen.addChild(this.winNumber);
    },

    async buildAutoModal() {
        const screen = new PIXI.Container();
        screen.removeChildren();
        this.modals.auto = screen;
        this.gameRoot.addChild(screen);
        screen.visible = false;

        screen.eventMode = "static";
        screen.on("pointerdown", (e) => {
            e.stopPropagation();
        });

        const windowContainer = new PIXI.Container();
        windowContainer.x = 10;
        windowContainer.y = 1900;

        const bg = new PIXI.Graphics();
        bg.roundRect(0, 0, 1100, 150, 5)
            .fill({ color: 0x000000, alpha: 0.9 })
            .stroke({ width: 4, color: 0xffffff });

        windowContainer.addChild(bg);
        screen.addChild(windowContainer);

        // ------------------------------------------------------------
        // Контейнеры
        // ------------------------------------------------------------
        const padding = 12;
        const btnWidth = 200;
        const btnHeight = 100;

        const buttonsContainer = new PIXI.Container();
        buttonsContainer.x = 25;
        buttonsContainer.y = 25;

        /*
                const startContainer = new PIXI.Container();
                startContainer.x = 360;
                startContainer.y = 105;
        */

        windowContainer.addChild(buttonsContainer);
        //windowContainer.addChild(startContainer);

        // ------------------------------------------------------------
        // Вспомогательная функция кнопки (скопирована по логике)
        // ------------------------------------------------------------
        const makeButton = (label, width, height, onClick, active = false) => {
            const btn = new PIXI.Container();
            btn.eventMode = "static";
            btn.cursor = active ? "default" : "pointer";

            const bg = new PIXI.Graphics();
            bg.roundRect(0, 0, width, height, 6)
                .fill({ color: active ? 0x5555aa : 0x333333 })
                .stroke({ width: 4, color: active ? 0xffffff : 0x777777 });
            btn.addChild(bg);

            const txt = new PIXI.Text({
                text: label,
                style: {
                    fill: active ? "#ffffaa" : "white",
                    fontSize: 44,
                    fontWeight: "bold"
                }
            });
            txt.x = (width - txt.width) / 2;
            txt.y = (height - txt.height) / 2;
            btn.addChild(txt);

            if (!active) {
                btn.on("pointerover", () => { bg.tint = 0x666666; });
                btn.on("pointerout", () => { bg.tint = 0xffffff; });
                btn.on("pointerdown", (e) => {
                    e.stopPropagation();
                    onClick();
                });
            }

            return btn;
        };

        // ------------------------------------------------------------
        // Кнопки количества автоспинов
        // ------------------------------------------------------------
        const counts = [10, 20, 50, 100, Infinity];

        const renderCounts = () => {
            buttonsContainer.removeChildren();

            let x = 0;
            let y = 0;

            counts.forEach((count) => {
                const isActive = this.autospin.count === count;

                const label = count === Infinity ? "∞" : String(count);

                const btn = makeButton(
                    label,
                    btnWidth,
                    btnHeight,
                    () => {
                        this.autospin.count = count;
                        this.autospin.enabled = true;
                        this.buttons.btnAuto.enable();
                        this.closeModal(this.modals.auto);
                        this.startSpin();
//                        renderCounts();
                    },
                    isActive
                );

                btn.x = x;
                btn.y = y;

                x += btnWidth + padding;
                if (x > 900) {
                    x = 0;
                    y += btnHeight + padding;
                }

                buttonsContainer.addChild(btn);
            });
        };

        // ------------------------------------------------------------
        // Кнопка START
        // ------------------------------------------------------------
        /*
                const startBtn = makeButton(
                    "START",
                    btnWidth * 2 + padding,
                    btnHeight,
                    () => {
                        if (this.autospin.count == null) return;
                        this.autospin.enabled = true;
                        this.closeModal(this.modals.autospin);
                        this.startSpin();
                    },
                    false
                );
                startContainer.addChild(startBtn);
        */

        // ------------------------------------------------------------
        // INIT
        // ------------------------------------------------------------
        renderCounts();
    },

    async buildSettingsModal() {
        const screen = new PIXI.Container();
        screen.removeChildren();
        this.modals.settings = screen;
        this.gameRoot.addChild(screen);
        screen.visible = false;

        screen.eventMode = "static";
        screen.on("pointertap", (e) => {
            screen.visible = false;
            e.stopPropagation();
        });

        screen.x = 10;
        screen.y = 10;

        const bg = new PIXI.Graphics();
        bg.roundRect(0, 0, this.gameWidth-20, this.gameHeight-20, 5)
            .fill({ color: 0x000000, alpha: 0.9 })
            .stroke({ width: 4, color: 0xffffff });
        screen.addChild(bg);



        const padding = 40;
        const leftColWidth = 320;
        const rowHeight = 120;

        const leftColX = padding;
        const rightColX = leftColX + leftColWidth + padding;

        let rowY = padding;


        const makeLabel = (text, y) => {
            const t = new PIXI.Text({
                text,
                style: {
                    fill: "#ffffff",
                    fontSize: 38,
                    fontWeight: "bold"
                }
            });
            t.x = leftColX;
            t.y = y + 35;
            screen.addChild(t);
        };

        makeLabel("SOUND", rowY);
        makeLabel("FULLSCREEN", rowY + rowHeight);
        makeLabel("LANGUAGE", rowY + rowHeight * 2);



        const makeToggleButton = (label, x, y, active, onClick) => {
            const btn = new PIXI.Container();
            btn.x = x;
            btn.y = y;

            btn.eventMode = "static";
            btn.cursor = "pointer";

            const bg = new PIXI.Graphics();
            bg.roundRect(0, 0, 150, 80, 6)
                .fill({ color: active ? 0x444444 : 0x222222 })
                .stroke({ width: 3, color: active ? 0xffffff : 0x777777 });
            btn.addChild(bg);

            const txt = new PIXI.Text({
                text: label,
                style: {
                    fill: active ? "#ffffff" : "#aaaaaa",
                    fontSize: 32,
                    compilation: true
                }
            });
            txt.x = (100 - txt.width) / 2;
            txt.y = (50 - txt.height) / 2;
            btn.addChild(txt);

            btn.on("pointerdown", (e) => {
                onClick();
                e.stopPropagation();
            });

            screen.addChild(btn);
        };

        makeToggleButton(
            "ON",
            rightColX,
            rowY + 30,
            this.sound === true,
            () => { this.sound = true; }
        );

        makeToggleButton(
            "OFF",
            rightColX + 180,
            rowY + 30,
            this.sound === false,
            () => { this.sound = false; }
        );

        makeToggleButton(
            "ON",
            rightColX,
            rowY + rowHeight + 30,
            this.fullscreen === true,
            () => { this.fullscreen = true; }
        );

        makeToggleButton(
            "OFF",
            rightColX + 180,
            rowY + rowHeight + 30,
            this.fullscreen === false,
            () => { this.fullscreen = false; }
        );


        let x = rightColX;
        let y = rowY + rowHeight * 2 + 10;

        const gap = 20;
        const btnSize = 100;
        const maxX = this.gameWidth - padding - btnSize;

        let activeLangFrame = null;

        for (const langCode in this.langs) {

            const assetName =
                "imgLang" + langCode.charAt(0).toUpperCase() + langCode.slice(1);

            const texture = PIXI.Assets.get(assetName);
            if (!texture) continue;

            if (x > maxX) {
                x = rightColX;
                y += btnSize + gap;
            }

            const btn = new PIXI.Container();
            btn.x = x;
            btn.y = y;

            btn.eventMode = "static";
            btn.cursor = "pointer";

            const icon = new PIXI.Sprite(texture);
            btn.addChild(icon);

            if (langCode === this.lang) {
                const frame = new PIXI.Graphics();
                frame.roundRect(
                    -6,
                    -6,
                    btnSize + 12,
                    btnSize + 12,
                    5
                )
                    .stroke({ width: 4, color: 0xffffff });
                btn.addChild(frame);
                activeLangFrame = frame;
            }

            btn.on("pointerdown", (e) => {

                if (this.lang !== langCode) {

                    // убрать старую рамку
                    if (activeLangFrame) {
                        activeLangFrame.destroy();
                        activeLangFrame = null;
                    }

                    // новая рамка
                    const frame = new PIXI.Graphics();
                    frame.roundRect(
                        -6,
                        -6,
                        btnSize + 12,
                        btnSize + 12,
                        5
                    )
                        .stroke({ width: 4, color: 0xffffff });

                    btn.addChild(frame);
                    activeLangFrame = frame;

                    this.lang = langCode;
                }

                this.reloadLang();
                this.lsSet('data', 'lang', langCode);
                screen.visible = false;
                e.stopPropagation();
            });

            screen.addChild(btn);

            x += btnSize + gap;
        }





















    },

    async buildHelpModal() {
        const screen = new PIXI.Container();
        screen.removeChildren();
        this.modals.help = screen;
        this.gameRoot.addChild(screen);
        screen.visible = false;



        // Поведение экрана
        screen.eventMode = "static";
        let __drag = false;
        let __dragMoved = false;
        let __startGlobalY = 0;
        let __startScreenY = 0;
        const __topY = screen.y+10;
        screen.on("pointerdown", (e) => {
            e.stopPropagation();
            __drag = true;
            __dragMoved = false;
            __startGlobalY = e.global.y;
            __startScreenY = screen.y;
        });
        screen.on("pointermove", (e) => {
            if (!__drag) return;
            e.stopPropagation();
            const dy = e.global.y - __startGlobalY;
            if (!__dragMoved && Math.abs(dy) >= 6) __dragMoved = true;
            if (__dragMoved) {
                let ny = __startScreenY + dy;

                const minY = __topY;
                const maxY = Math.min(
                    __topY,
                    this.gameHeight - screen.height + __topY
                );

                if (ny > minY) ny = minY;
                if (ny < maxY) ny = maxY;

                screen.y = ny;
            }
        });
        const __endDrag = (e) => {
            if (!__drag) return;
            e.stopPropagation();

            const wasMoved = __dragMoved;

            __drag = false;
            __dragMoved = false;

            if (!wasMoved) screen.visible = false;
        };

        screen.on("pointerup", __endDrag);
        screen.on("pointerupoutside", __endDrag);

        // wheel на контейнер через DOM (минимально)
        if (!this.__helpWheelHandler) {
            this.__helpWheelHandler = (ev) => {
                if (!screen.visible) return;
                ev.preventDefault();
                let ny = screen.y - ev.deltaY;

                const minY = __topY;
                const maxY = Math.min(
                    __topY,
                    this.gameHeight - screen.height + __topY
                );

                if (ny > minY) ny = minY;
                if (ny < maxY) ny = maxY;

                screen.y = ny;
            };
            this.pixi.canvas.addEventListener("wheel", this.__helpWheelHandler, { passive: false });

        }

        // Содержимое экрана
        screen.x = 10;
        screen.y = 10;

        const bg = new PIXI.Graphics();
        bg.roundRect(0, 0, this.gameWidth-20, this.gameHeight-20, 20)
            .fill({ color: 0x000000, alpha: 0.9 })
            .stroke({ width: 4, color: 0xffffff });
        screen.addChild(bg);

// title
        const title = new PIXI.Text({
            text: "Lines",
            style: {
                fill: 0xffffff,
                fontSize: 72,
                fontWeight: "bold"
            }
        });
        title.anchor.set(0.5, 0);
        title.x = (this.gameWidth - 20) / 2;
        title.y = 20;
        screen.addChild(title);

// Генерация линий
        let lineX = 50;
        let lineY = title.y + title.height + 30;

        const items = [];
        this.data.lines.forEach((line, key) => {
            const lineNum = key+1;

            const c = new PIXI.Container();

            const t = new PIXI.Text({
                text: lineNum + ":",
                style: {
                    fill: 0xffffff,
                    fontSize: 36,
                    fontWeight: "bold"
                }
            });
            c.addChild(t);

            const mx = 80;
            this.drawLinesMatrix(c, line, this.lines_colors[lineNum][0], mx, 0, 30, 15, 4);

            t.y = ((3 * 30 + 2 * 15) - t.height) / 2;

            items.push(c);
            screen.addChild(c);
        });

// layout (centered)
        let row = [];
        let rowW = 0;
        let y = lineY;

        const flushRow = () => {
            if (!row.length) return;
            let x = ((this.gameWidth - 20) - rowW) / 2;
            for (const it of row) {
                it.x = x;
                it.y = y;
                x += it.width + 60;
            }
            y += (3 * 30 + 2 * 15) + 40;
            row = [];
            rowW = 0;
        };

        for (const it of items) {
            const w = it.width;
            const nextW = row.length ? (rowW + 60 + w) : w;

            if (nextW > (this.gameWidth - 20) && row.length) {
                flushRow();
            }

            rowW = row.length ? (rowW + 60 + w) : w;
            row.push(it);
        }
        flushRow();
    },

    drawLinesMatrix(screen, matrix, color, x = 0, y = 0, size = 20, gap, lineWidth) {
        for (let row = 0; row < 3; row++) {
            const r = matrix[row] || [];
            for (let col = 0; col < 5; col++) {
                const v = r[col] ? 1 : 0;
                const sx = x + col * (size + gap);
                const sy = y + row * (size + gap);
                screen.addChild(this.drawSquare(sx, sy, size, v ? color : 0xffffff, v?true:false, lineWidth));
            }
        }
    },

    drawSquare(x, y, size, color, filled = true, lineWidth = 1) {
        const g = new PIXI.Graphics();
        g.rect(x, y, size, size);
        g.stroke({ width: lineWidth, color });
        if (filled) g.fill(color);
        return g;
    },

    buildBg() {
        this.screens.bg.removeChildren();

        const texture = PIXI.Assets.get('imgBgMain');
        if (!texture) return;

        const bg = new PIXI.Sprite(texture);

        // якорь: центр по X, верх по Y
        bg.anchor.set(0.5, 0);

        this.screens.bg.addChild(bg);

        // сохраняем ссылку для resize
        this.bgSprite = bg;

        // интерактив для клика "вне модалки"
        bg.eventMode = "static";

        bg.on("pointerdown", () => {
            for (const key in this.modals) {
                const modal = this.modals[key];
                if (modal && modal.visible && !modal.noBgClose) {
                    modal.visible = false;
                }
            }
        });

        // первичная подгонка
        this.resizeBg();
    },

    resizeBg() {
        if (!this.bgSprite) return;

        const sw = this.pixi.renderer.width;
        const sh = this.pixi.renderer.height;

        const tex = this.bgSprite.texture;

        // масштабируем по высоте экрана
        const scale = sh / tex.height;

        this.bgSprite.scale.set(scale);

        // центрируем по X
        this.bgSprite.x = sw / 2;
        this.bgSprite.y = 0;
    },

    async buildGameScreen() {
        const screen = this.screens.game;
        screen.removeChildren();

        // маска
/*
        const mask = new PIXI.Graphics();
        mask.beginFill(0xffffff);
        mask.drawRect(0, 0, this.gameWidth, this.gameHeight);
        mask.endFill();

        this.gameRoot.addChild(mask);
        screen.mask = mask;
        this.gameMask = mask;
*/

        // Рамка
        //screen.addChild(new PIXI.Graphics().rect(0, 0, this.gameWidth, this.gameHeight).stroke({ width: 4, color: 0xff0000 }));


        const cx = this.gameWidth / 2;
        const cy = this.gameHeight / 2;

        // Основные блоки
        const logo = new PIXI.Sprite(PIXI.Assets.get('imgLogo'));
        logo.anchor.set(0.5, 0.5);
        logo.x = cx;
        logo.y = 280;
        logo.scale = 0.5;
        screen.logo = logo;
        screen.addChild(logo);

        // Блок джекпотов
        const jpContainer = new PIXI.Container();
        jpContainer.x = cx-570;
        jpContainer.y = cy - 740;
        screen.addChild(jpContainer);
        screen.jpContainer = jpContainer;

        const fieldWidth = 540;
        const fieldHeight = 80;
        const colGap = 60;
        const rowGap = 15;

        const col1x = 0;
        const col2x = fieldWidth + colGap;
        const row1y = 0;
        const row2y = fieldHeight + rowGap;
        this.jpText = [];
        const createJackpotField = (x, y, iconAsset, index) => {
            const c = new PIXI.Container();
            c.x = x;
            c.y = y;

            const g = new PIXI.Graphics();
            g.roundRect(0, 0, fieldWidth, fieldHeight, 20)
                .fill({ color: 0x000000, alpha: 0.7 })
                .stroke({ width: 4, color: 0xffffff, alpha: 0.7 });

            // иконка джекпота
            const icon = new PIXI.Sprite(PIXI.Assets.get(iconAsset));
            icon.anchor.set(0.5);
            icon.x = 50;
            icon.y = fieldHeight / 2;
            //icon.scale.set(0.6);

            // текст джекпота
            const t = new PIXI.Text({
                text: "",
                style: {
                    fill: "#ffffff",
                    fontSize: 44,
                    fontWeight: "500"
                }
            });
            //t.anchor.set(0.5);
            t.x = 100;
            t.y = 15;
            c.addChild(g, icon, t);
            c.bg = g;
            c.icon = icon;
            c.text = t;
            this.jpText[index] = t;
            jpContainer.addChild(c);
            return c;
        };

        createJackpotField(col1x, row1y, "imgJp1", 0);
        createJackpotField(col2x, row1y, "imgJp2", 1);
        createJackpotField(col1x, row2y, "imgJp3", 2);
        createJackpotField(col2x, row2y, "imgJp4", 3);

        const reelsContainer = new PIXI.Container();
        reelsContainer.x = -1;
        reelsContainer.y = cy - 550;
        screen.addChild(reelsContainer);
        this.reelsContainer = reelsContainer;

        // создаём слой, который будет двигаться
        this.reelsHolder = new PIXI.Container();
        this.reelsContainer.addChild(this.reelsHolder);

        const reelsMask = new PIXI.Graphics();
        reelsMask.beginFill(0xffffff);
        reelsMask.drawRoundedRect(0, 0, 1230, 738, 40);
        reelsMask.endFill();
        reelsMask.x = 0;
        reelsMask.y = 0;
        reelsContainer.addChild(reelsMask);
        reelsContainer.mask = reelsMask;

        await this.createReels();
        this.fillReels(this.game.comb);

        //
        // 3. GOOD LUCK панель под полями
        //
        const goodWidth = 1180;
        const goodHeight = 150;
        const goodX = cx - goodWidth / 2;
        const goodY = cy + 215;

        const goodPanel = new PIXI.Container();
        goodPanel.x = goodX;
        goodPanel.y = goodY;
        screen.goodPanel = goodPanel;

        const goodBg = new PIXI.Graphics();
        goodBg.roundRect(0, 0, goodWidth, goodHeight, 20)
            .fill({color: 0x000000, alpha: 0.7})
            .stroke({width: 3, color: 0xffffff, alpha: 1});
        goodPanel.addChild(goodBg);

        const goodText = new PIXI.Text({
            text: this.getText("default"),
            style: {
                fill: "#ffffff",
                fontSize: 54,
                fontWeight: "bold"
            }
        });
        goodText.anchor.set(0.5);
        goodText.x = goodWidth / 2;
        goodText.y = 40;
        goodPanel.addChild(goodText);
        this.texts.goodluck = goodText;

        const infoText = new PIXI.Text({
            text: "",
            style: {
                fill: "#ffffff",
                fontSize: 34,
                fontWeight: "bold"
            }
        });
        infoText.anchor.set(0.5);
        infoText.x = goodWidth / 2;
        infoText.y = 100;
        goodPanel.addChild(infoText);
        this.texts.info = infoText;

        screen.addChild(goodPanel);

        const betsWidth = 1180;
        const betsHeight = 200;
        const betsX = cx - betsWidth / 2;
        const betsY = this.gameHeight - 250;

        const betsPanel = new PIXI.Container();
        betsPanel.x = betsX;
        betsPanel.y = betsY;
        screen.betPanel = betsPanel;

        const betsBg = new PIXI.Graphics();
        betsBg.roundRect(0, 0, betsWidth, betsHeight, 20)
            .fill({color: 0x000000, alpha: 0.7})
            .stroke({width: 4, color: 0xffffff, alpha: 1});
        betsPanel.addChild(betsBg);

        const balanceTitleText = new PIXI.Text({
            text: this.getText("balance") + " (" + this.data.currency + ")",
            style: {
                fill: "gold",
                fontSize: 40,
                fontWeight: "bold"
            }
        });
        balanceTitleText.anchor.set(0.5);
        balanceTitleText.x = 180;
        balanceTitleText.y = 50;
        this.texts.balanceTitle = balanceTitleText;
        betsPanel.addChild(balanceTitleText);

        const balanceText = new PIXI.Text({
            text: this.data.balance,
            style: {
                fill: "#ffffff",
                fontSize: 60,
                fontWeight: "bold"
            }
        });
        balanceText.anchor.set(0.5);
        balanceText.x = 180;
        balanceText.y = 130;
        this.data.balanceText = balanceText;
        betsPanel.addChild(balanceText);

        const betCaption = new PIXI.Text({
            text: this.getText("bet"),
            style: {
                fill: "gold",
                fontSize: 40,
                fontWeight: "bold"
            }
        });
        betCaption.anchor.set(0.5);
        betCaption.x = 500;
        betCaption.y = 50;
        this.texts.betsTitle = betCaption;
        betsPanel.addChild(betCaption);
        betCaption.eventMode = "static";     // включает участие в событиях
        betCaption.cursor = "pointer";       // меняет курсор на руку
        betCaption.on("click", () => {
            this.toggleModal(this.modals.bets);
        });

        const linesCaption = new PIXI.Text({
            text: this.getText("lines"),
            style: {
                fill: "gold",
                fontSize: 40,
                fontWeight: "bold"
            }
        });
        linesCaption.anchor.set(0.5);
        linesCaption.x = 680;
        linesCaption.y = 50;
        this.texts.linesTitle = linesCaption;
        betsPanel.addChild(linesCaption);
        linesCaption.eventMode = "static";     // включает участие в событиях
        linesCaption.cursor = "pointer";       // меняет курсор на руку
        linesCaption.on("click", () => {
            this.toggleModal(this.modals.bets);
        });


        const betText = new PIXI.Text({
            text: this.game.bet,
            style: {
                fill: "#ffffff",
                fontSize: 60,
                fontWeight: "bold"
            }
        });
        betText.anchor.set(0.5);
        betText.x = 500;
        betText.y = 130;
        this.data.betText = betText;
        betsPanel.addChild(betText);

        const linesText = new PIXI.Text({
            text: this.game.lines,
            style: {
                fill: "#ffffff",
                fontSize: 60,
                fontWeight: "bold"
            }
        });
        linesText.anchor.set(0.5);
        linesText.x = 680;
        linesText.y = 130;
        this.data.linesText = linesText;
        betsPanel.addChild(linesText);

        const lastWinCaption = new PIXI.Text({
            text: this.getText("last_win"),
            style: {
                fill: "gold",
                fontSize: 40,
                fontWeight: "bold"
            }
        });
        lastWinCaption.anchor.set(0.5);
        lastWinCaption.x = 1000;
        lastWinCaption.y = 50;
        this.texts.lastWinTitle = lastWinCaption;
        betsPanel.addChild(lastWinCaption);

        const winText = new PIXI.Text({
            text: "0",
            style: {
                fill: "#fff",
                fontSize: 60,
                fontWeight: "bold"
            }
        });
        winText.anchor.set(0.5);
        winText.x = 1000;
        winText.y = 130;
        betsPanel.addChild(winText);
        this.data.lastWinText = winText;

        screen.addChild(betsPanel);

        const upperBtnContainer = new PIXI.Container();
        screen.upperBtnContainer = upperBtnContainer;
        screen.addChild(upperBtnContainer);
        upperBtnContainer.x = cx - this.gameWidth/2 + 150;
        upperBtnContainer.y = 150;

        const btnMenu = this.createMenuButton(0, 0);
        upperBtnContainer.addChild(btnMenu);

        const btnSound = this.createSoundButton(150, 100);
        upperBtnContainer.addChild(btnSound);

        const btnHelp = this.createHelpButton(cx + this.gameWidth/2 - 450, 100);
        upperBtnContainer.addChild(btnHelp);

        const btnClose = this.createCloseButton(cx + this.gameWidth/2 - 300, 0);
        upperBtnContainer.addChild(btnClose);


        const bottomBtnContainer = new PIXI.Container();
        screen.bottomBtnContainer = bottomBtnContainer;
        screen.addChild(bottomBtnContainer);
        bottomBtnContainer.x = cx - 300;
        bottomBtnContainer.y = this.gameHeight - 450;


        const btnSpin = this.createSpinButton(300, 0);
        bottomBtnContainer.addChild(btnSpin);

        const btnSpeed = this.createSpeedButton(232, 150, 1.4);
        bottomBtnContainer.addChild(btnSpeed);

        const btnAuto = this.createAutoButton(0, 60);
        bottomBtnContainer.addChild(btnAuto);

        const btnMoney = this.createMoneyButton(600, 60);
        bottomBtnContainer.addChild(btnMoney);

        this.buttons = {btnMenu, btnSound, btnHelp, btnClose, btnSpin, btnSpeed, btnAuto, btnMoney};
    },

    resizeGameScreen() {
        const screen = this.screens.game;
        const cx = this.gameWidth/2;
        const cy = this.gameHeight/2;

        // Лого
        const maxLogoY = Math.max(this.reelsContainer.y - screen.logo.height, 0);
        const defLogoY = 280;
        const logoY = Math.min(defLogoY, maxLogoY);
        screen.logo.y = logoY;

        // Верхние кнопки
        screen.upperBtnContainer.y = 150;

        // Блок джекпотов
        screen.jpContainer.y = cy - 740;

        // Блок барабанов
        this.reelsContainer.y = cy - 550;
        this.modals.wins.y = this.reelsContainer.y;

        // Блок инфо
        screen.goodPanel.y = cy + 215;

        // Блок ставок
        screen.betPanel.y = this.gameHeight - 250;

        // Блок нижних кнопок
        const bottomButtonsY = (this.gameHeight - 550- cy + 475) / 2;
        screen.bottomBtnContainer.y = cy + bottomButtonsY;



        //console.log(this.gameHeight);

    },

    createMenuButton(x = 0, y = 0, scale = 1) {

        // уровни прозрачности
        const ALPHA_DISABLED = 0.6;
        const ALPHA_NORMAL   = 0.7;
        const ALPHA_HOVER    = 0.9;
        const ALPHA_CLICKED = 0.8;

        const btn = new PIXI.Container();
        btn.x = x;
        btn.y = y;
        //btn.scale.set(scale);
        btn.interactive = true;
        btn.cursor = 'pointer';
        btn.disabled = false;

        // фон
        const bg = new PIXI.Sprite(PIXI.Assets.get('imgBtnBg'));
        bg.anchor.set(0.5);
        btn.addChild(bg);

        // иконки
        const icon = new PIXI.Sprite(PIXI.Assets.get('imgBtnBurger'));
        icon.anchor.set(0.5);
        //icon.scale.set(1.2);
        icon.x = 0;
        icon.y = 0;


        icon.visible = true;

        btn.addChild(icon);

        // ссылки
        btn.icon = icon;
        // состояния
        // интерактив
        btn.on('pointerover', () => {
            if (!btn.disabled) btn.icon.alpha = ALPHA_HOVER;
        });

        btn.on('pointerout', () => {
            if (!btn.disabled) btn.icon.alpha = ALPHA_NORMAL;
        });

        btn.on('pointerdown', () => {
            if (!btn.disabled) btn.icon.alpha = ALPHA_CLICKED;
        });

        btn.on('pointerup', () => {
            if (!btn.disabled) btn.icon.alpha = ALPHA_HOVER;
        });

        btn.on('pointertap', () => {
            this.modals.settings.visible = true;
        });

        btn.on('pointerupoutside', () => {
            if (!btn.disabled) btn.icon.alpha = ALPHA_NORMAL;
        });

        // стартовая альфа
        btn.icon.alpha = ALPHA_NORMAL;

        return btn;
    },

    createSoundButton(x = 0, y = 0, scale = 1) {

        // уровни прозрачности
        const ALPHA_DISABLED = 0.6;
        const ALPHA_NORMAL   = 0.7;
        const ALPHA_HOVER    = 0.9;
        const ALPHA_CLICKED = 0.8;

        const btn = new PIXI.Container();
        btn.x = x;
        btn.y = y;
        //btn.scale.set(scale);
        btn.interactive = true;
        btn.cursor = 'pointer';
        btn.disabled = false;

        // фон
        const bg = new PIXI.Sprite(PIXI.Assets.get('imgBtnBg'));
        bg.anchor.set(0.5);
        btn.addChild(bg);

        // иконки
        const speaker = new PIXI.Sprite(PIXI.Assets.get('imgBtnSpeaker'));
        speaker.anchor.set(0.5);
        //speaker.scale.set(1.7);
        speaker.x = -7;
        speaker.y = 0;
        btn.addChild(speaker);
        btn.speaker = speaker;

        // иконки
        const wave = new PIXI.Sprite(PIXI.Assets.get('imgBtnWave'));
        wave.anchor.set(0.5);
        //wave.scale.set(1.7);
        wave.x = 7;
        wave.y = 0;
        btn.addChild(wave);
        btn.wave = wave;
        if (!this.sound) wave.visible = false;


        // иконки
        const cross = new PIXI.Sprite(PIXI.Assets.get('imgBtnCrossSmall'));
        cross.anchor.set(0.5);
        //cross.scale.set(0.9);
        cross.x = 11;
        cross.y = 0;
        btn.addChild(cross);
        btn.cross = cross;
        if (this.sound) cross.visible = false;



        btn.on('pointerover', () => {
            if (!btn.disabled) btn.speaker.alpha = ALPHA_HOVER;
        });

        btn.on('pointerout', () => {
            if (!btn.disabled) btn.speaker.alpha = ALPHA_NORMAL;
        });

        btn.on('pointerdown', () => {
            if (!btn.disabled) btn.speaker.alpha = ALPHA_CLICKED;
        });

        btn.on('pointertap', () => {
            if (this.sound) {
                this.sound = false;
                btn.wave.visible = false;
                btn.cross.visible = true;
                this.lsSet('data', 'sound', false);
            } else {
                this.sound = true;
                btn.wave.visible = true;
                btn.cross.visible = false;
                this.lsSet('data', 'sound', true);
            }
        });

        btn.on('pointerupoutside', () => {
            if (!btn.disabled) btn.speaker.alpha = ALPHA_NORMAL;
        });

        // стартовая альфа
        btn.speaker.alpha = ALPHA_NORMAL;

        return btn;
    },

    createHelpButton(x = 0, y = 0, scale = 1) {

        // уровни прозрачности
        const ALPHA_DISABLED = 0.6;
        const ALPHA_NORMAL   = 0.7;
        const ALPHA_HOVER    = 0.9;
        const ALPHA_CLICKED = 0.8;

        const btn = new PIXI.Container();
        btn.x = x;
        btn.y = y;
        //btn.scale.set(scale);
        btn.interactive = true;
        btn.cursor = 'pointer';
        btn.disabled = false;

        // фон
        const bg = new PIXI.Sprite(PIXI.Assets.get('imgBtnBg'));
        bg.anchor.set(0.5);
        btn.addChild(bg);

        // иконки
        const icon = new PIXI.Sprite(PIXI.Assets.get('imgBtnHelp'));
        icon.anchor.set(0.5);
        //icon.scale.set(1.8);
        icon.x = 0;
        icon.y = 0;
        icon.visible = true;

        btn.addChild(icon);

        // ссылки
        btn.icon = icon;
        // состояния
        // интерактив
        btn.on('pointerover', () => {
            if (!btn.disabled) btn.icon.alpha = ALPHA_HOVER;
        });

        btn.on('pointerout', () => {
            if (!btn.disabled) btn.icon.alpha = ALPHA_NORMAL;
        });

        btn.on('pointerdown', () => {
            if (!btn.disabled) btn.icon.alpha = ALPHA_CLICKED;
        });

        btn.on('pointerup', () => {
            if (!btn.disabled) btn.icon.alpha = ALPHA_HOVER;
        });

        btn.on('pointertap', async () => {
            await this.buildHelpModal();
            this.modals.help.visible = true;
        });

        btn.on('pointerupoutside', () => {
            if (!btn.disabled) btn.icon.alpha = ALPHA_NORMAL;
        });

        // стартовая альфа
        btn.icon.alpha = ALPHA_NORMAL;

        return btn;
    },

    createCloseButton(x = 0, y = 0, scale = 1) {

        // уровни прозрачности
        const ALPHA_DISABLED = 0.6;
        const ALPHA_NORMAL   = 0.7;
        const ALPHA_HOVER    = 0.9;
        const ALPHA_CLICKED = 0.8;

        const btn = new PIXI.Container();
        btn.x = x;
        btn.y = y;
        //btn.scale.set(scale);
        btn.interactive = true;
        btn.cursor = 'pointer';
        btn.disabled = false;

        // фон
        const bg = new PIXI.Sprite(PIXI.Assets.get('imgBtnBg'));
        bg.anchor.set(0.5);
        btn.addChild(bg);

        // иконки
        const icon = new PIXI.Sprite(PIXI.Assets.get('imgBtnCross'));

        icon.anchor.set(0.5);

        //icon.scale.set(1.8);

        icon.x = 0;
        icon.y = 0;


        icon.visible = true;

        btn.addChild(icon);

        // ссылки
        btn.icon = icon;
        // состояния
        // интерактив
        btn.on('pointerover', () => {
            if (!btn.disabled) btn.icon.alpha = ALPHA_HOVER;
        });

        btn.on('pointerout', () => {
            if (!btn.disabled) btn.icon.alpha = ALPHA_NORMAL;
        });

        btn.on('pointerdown', () => {
            if (!btn.disabled) btn.icon.alpha = ALPHA_CLICKED;
        });

        btn.on('pointertap', () => {
            if (!btn.disabled) btn.icon.alpha = ALPHA_CLICKED;
            this.toggleFullscreen();
        });

        btn.on('pointerup', () => {
            if (!btn.disabled) {
                btn.icon.alpha = ALPHA_HOVER;
            }
        });

        btn.on('pointerupoutside', () => {
            if (!btn.disabled) btn.icon.alpha = ALPHA_NORMAL;
        });

        // стартовая альфа
        btn.icon.alpha = ALPHA_NORMAL;

        return btn;
    },

    createSpinButton(x = 0, y = 0, scale = 1) {

        // уровни прозрачности
        const ALPHA_DISABLED = 0.6;
        const ALPHA_NORMAL   = 0.7;
        const ALPHA_HOVER    = 0.9;

        const btn = new PIXI.Container();
        btn.x = x;
        btn.y = y;
        btn.interactive = true;
        //btn.scale.set(scale);
        btn.cursor = 'pointer';
        btn.disabled = false;

        // фон
        const bg = new PIXI.Sprite(PIXI.Assets.get('imgBtnBgSpin'));
        bg.anchor.set(0.5);
        btn.addChild(bg);

        // иконки
        const iconTriangle = new PIXI.Sprite(PIXI.Assets.get('imgBtnTriangle'));
        const iconRect     = new PIXI.Sprite(PIXI.Assets.get('imgBtnRect'));

        iconTriangle.anchor.set(0.5);
        iconRect.anchor.set(0.5);

        iconTriangle.x = 8;
        iconTriangle.y = 0;

        iconTriangle.visible = true;
        iconRect.visible = false;

        btn.addChild(iconTriangle, iconRect);

        // счётчик автоспинов (опционально; можно стилизовать/позиционировать под себя)
        const counter = new PIXI.Text({
            text: "",
            style: {
                fill: "#ffffff",
                fontSize: 50,
                fontWeight: "bold",
                stroke: "#000000",
                strokeThickness: 4
            }
        });
        counter.anchor.set(0.5);
        counter.x = 0;
        counter.y = 0;
        counter.visible = false;
        btn.addChild(counter);

        // ссылки (сохраняем ваши поля)
        btn.iconTriangle = iconTriangle;
        btn.iconRect = iconRect;
        btn.icon = iconTriangle;
        btn.counter = counter;

        // состояние (внутреннее, для корректного UI)
        btn._autospinEnabled = false;
        btn._autospinCount = 0;
        btn._spinning = false;

        btn.isAuto = this.autospin;

        // единая функция отрисовки состояния
        btn._sync = function () {
            const autospin = btn.isAuto;
            // --- АВТОРЕЖИМ ---
            if (autospin.enabled) {
                // иконка всегда STOP
                btn.iconTriangle.visible = false;
                btn.iconRect.visible = true;
                btn.icon = btn.iconRect;
                // обновляем ТОЛЬКО счётчик
                btn.counter.visible = true;
                btn.counter.text = String(autospin.count ?? "");
                btn.icon.alpha = btn.disabled ? ALPHA_DISABLED : ALPHA_NORMAL;
            } else {
                // --- РУЧНОЙ РЕЖИМ ---
                btn.counter.visible = false;
                btn.counter.text = "";

                if (btn._spinning) {
                    btn.iconTriangle.visible = false;
                    btn.iconRect.visible = true;
                    btn.icon = btn.iconRect;
                } else {
                    btn.iconRect.visible = false;
                    btn.iconTriangle.visible = true;
                    btn.icon = btn.iconTriangle;
                }
            }
            btn.icon.alpha = btn.disabled ? ALPHA_DISABLED : ALPHA_NORMAL;
        };

        // состояния (сохраняем ваши методы)
        btn.disable = function () {
            this.disabled = true;
            this.icon.alpha = ALPHA_DISABLED;
        };

        btn.enable = function () {
            this.disabled = false;
            this.icon.alpha = ALPHA_NORMAL;
        };

        // ВАЖНО: сохраняем контракт btn.spinned(spin)
        // - spin=true  -> показываем квадрат
        // - spin=false -> показываем треугольник ТОЛЬКО если не включен автоспин
        btn.spinned = function (spin) {
            btn._spinning = !!spin;

            // если автоспин активен — не даём вернуть треугольник
            btn._sync();
        };

        // Новый (доп.) метод для автоспина (не ломает старые вызовы)
        // дергайте его, когда меняется состояние автоспина или счётчик
        btn.setAutospin = function (enabled, count = 0) {
            btn._autospinEnabled = !!enabled;
            btn._autospinCount = Number(count) || 0;
            btn._sync();
        };

        // интерактив (без press/release)
        btn.on('pointerover', () => {
            if (!btn.disabled) btn.icon.alpha = ALPHA_HOVER;
        });

        btn.on('pointerout', () => {
            if (!btn.disabled) btn.icon.alpha = ALPHA_NORMAL;
        });

        // ТОЛЬКО click
        btn.on('pointertap', () => {
            // --- АВТОРЕЖИМ ---
            if (this.autospin.enabled) {

                // выключаем авто
                this.autospin.enabled = false;
                this.autospin.count = 0;

                btn._spinning = false;
                btn._sync();

                // остановка стрелок авто-кнопки
                if (this.buttons.btnAuto) {
                    this.buttons.btnAuto.disable();
                }

                return;
            }

            // --- РУЧНОЙ РЕЖИМ ---
            if (btn._spinning) {

                // мгновенная остановка
                this.sortReelSlotsInstant();
                return;
            }

            // старт обычного спина
            btn._spinning = true;
            btn._sync();

            this.startSpin();
        });

        // стартовое состояние
        btn._sync();

        return btn;
    },

    createSpeedButton(x = 0, y = 0, scale = 1) {

        const ACTIVE_ALPHA = 1;
        const INACTIVE_ALPHA = 0.6;

        const btn = new PIXI.Container();
        btn.x = x;
        btn.y = y;
        btn.interactive = true;
        btn.cursor = 'pointer';
        btn.disabled = false;

        const btnBg = new PIXI.Graphics();
        btnBg.roundRect(0, 0, 135, 55, 10)
            .fill({color: 0x000000, alpha: 0.7});
            //.stroke({width: 2, color: 0xffffff, alpha: 1});

        btn.addChild(btnBg);

        const triangle1 = new PIXI.Sprite(PIXI.Assets.get('imgBtnTriangleSmall'));
        triangle1.anchor.set(0.5);
        triangle1.x = 32;
        triangle1.y = 27;
        triangle1.alpha = ACTIVE_ALPHA;
        btn.triangle1 = triangle1;
        btn.addChild(triangle1);

        const triangle2 = new PIXI.Sprite(PIXI.Assets.get('imgBtnTriangleSmall'));
        triangle2.anchor.set(0.5);
        triangle2.x = 67;
        triangle2.y = 27;
        triangle2.alpha = (this.game.speed >= 2) ? ACTIVE_ALPHA : INACTIVE_ALPHA;
        btn.triangle2 = triangle2;
        btn.addChild(triangle2);

        const triangle3 = new PIXI.Sprite(PIXI.Assets.get('imgBtnTriangleSmall'));
        triangle3.anchor.set(0.5);
        triangle3.x = 102;
        triangle3.y = 27;
        triangle3.alpha = (this.game.speed >= 3) ? ACTIVE_ALPHA : INACTIVE_ALPHA;
        btn.triangle3 = triangle3;
        btn.addChild(triangle3);

        btn.setState = function (num){
            this.triangle1.alpha = (num >= 1) ? ACTIVE_ALPHA : INACTIVE_ALPHA;
            this.triangle2.alpha = (num >= 2) ? ACTIVE_ALPHA : INACTIVE_ALPHA;
            this.triangle3.alpha = (num >= 3) ? ACTIVE_ALPHA : INACTIVE_ALPHA;
        };

        btn.on('pointertap', () => {
            this.game.speed++;
            if (this.game.speed > 3) this.game.speed = 1;
            this.lsSet('game', 'speed', this.game.speed);

            btn.setState(this.game.speed);
        });

        return btn;
    },

    createMoneyButton(x = 0, y = 0, scale = 1) {

        // уровни прозрачности
        const ALPHA_DISABLED = 0.6;
        const ALPHA_NORMAL   = 0.7;
        const ALPHA_HOVER    = 0.9;
        const ALPHA_CLICKED = 0.8;

        const btn = new PIXI.Container();
        btn.x = x;
        btn.y = y;
        //btn.scale.set(scale);
        btn.interactive = true;
        btn.cursor = 'pointer';
        btn.disabled = false;

        // фон
        const bg = new PIXI.Sprite(PIXI.Assets.get('imgBtnBg'));
        bg.anchor.set(0.5);
        btn.addChild(bg);

        // иконки
        const icon = new PIXI.Sprite(PIXI.Assets.get('imgBtnMoney'));

        icon.anchor.set(0.5);

        //icon.scale.set(1.1);

        icon.x = 0;
        icon.y = 0;


        icon.visible = true;

        btn.addChild(icon);

        // ссылки
        btn.icon = icon;
        // состояния
        // интерактив
        btn.on('pointerover', () => {
            if (!btn.disabled) btn.icon.alpha = ALPHA_HOVER;
        });

        btn.on('pointerout', () => {
            if (!btn.disabled) btn.icon.alpha = ALPHA_NORMAL;
        });

        btn.on('pointerdown', () => {
            if (!btn.disabled) btn.icon.alpha = ALPHA_CLICKED;
        });

        btn.on('pointertap', () => {
            if (!btn.disabled) {
                btn.icon.alpha = ALPHA_HOVER;
                this.toggleModal(this.modals.bets);
            }
        });

        btn.on('pointerupoutside', () => {
            if (!btn.disabled) btn.icon.alpha = ALPHA_NORMAL;
        });

        // стартовая альфа
        btn.icon.alpha = ALPHA_NORMAL;

        return btn;
    },

    createAutoButton(x = 0, y = 0, scale = 1) {

        // уровни прозрачности
        const ALPHA_DISABLED = 0.6;
        const ALPHA_NORMAL   = 0.7;
        const ALPHA_HOVER    = 0.9;
        const ALPHA_CLICKED = 0.8;

        const btn = new PIXI.Container();
        btn.x = x;
        btn.y = y;
        //btn.scale.set(scale);
        btn.interactive = true;
        btn.cursor = 'pointer';
        btn.disabled = false;

        // фон
        const bg = new PIXI.Sprite(PIXI.Assets.get('imgBtnBg'));
        bg.anchor.set(0.5);
        btn.addChild(bg);

        // иконки
        const icon = new PIXI.Sprite(PIXI.Assets.get('imgBtnAuto'));
        icon.anchor.set(0.5);
        //icon.scale.set(1.1);
        icon.x = 0;
        icon.y = 0;
        btn.addChild(icon);

        // иконки
        const arrows = new PIXI.Sprite(PIXI.Assets.get('imgBtnArrows'));
        arrows.anchor.set(0.5);
        //arrows.scale.set(1.1);
        arrows.x = 0;
        arrows.y = 0;

        btn.addChild(arrows);

        // ссылки
        btn.icon = icon;
        btn.arrows = arrows;

        // интерактив
        btn._spinFn = () => {
            btn.arrows.angle += 3; // градусы, по часовой
            if (btn.arrows.angle >= 360) {
                btn.arrows.angle -= 360;
            }
        };

        btn._stopFn = () => {
            let a = btn.arrows.angle;

            if (a === 0) {
                PIXI.Ticker.shared.remove(btn._stopFn);
                btn._stopActive = false;
                return;
            }

            if (a > 180) a -= 360;

            const step = Math.min(5, Math.abs(a));
            btn.arrows.angle -= Math.sign(a) * step;

            if (Math.abs(btn.arrows.angle) < 1) {
                btn.arrows.angle = 0;
            }
        };

        btn._spinActive = false;
        btn._stopActive = false;

        btn.enable = function () {
            // если шла доводка — немедленно отменяем
            if (btn._stopActive) {
                PIXI.Ticker.shared.remove(btn._stopFn);
                btn._stopActive = false;
            }

            if (btn._spinActive) return;

            PIXI.Ticker.shared.add(btn._spinFn);
            btn._spinActive = true;
        };

        btn.disable = function () {

            if (btn._spinActive) {
                PIXI.Ticker.shared.remove(btn._spinFn);
                btn._spinActive = false;
            }

            if (btn._stopActive) return;

            PIXI.Ticker.shared.add(btn._stopFn);
            btn._stopActive = true;
        };

        btn.on('pointerover', () => {
            if (!btn.disabled) {
                btn.icon.alpha = ALPHA_HOVER;
                btn.arrows.alpha = ALPHA_HOVER;
            }
        });

        btn.on('pointerout', () => {
            if (!btn.disabled) {
                btn.icon.alpha = ALPHA_NORMAL;
                btn.arrows.alpha = ALPHA_NORMAL;
            }
        });

        btn.on('pointerdown', () => {
            if (!btn.disabled) {
                btn.icon.alpha = ALPHA_CLICKED;
                btn.arrows.alpha = ALPHA_CLICKED;
            }
        });

        btn.on('pointerup', () => {
            if (!btn.disabled) {
                btn.icon.alpha = ALPHA_HOVER;
                btn.arrows.alpha = ALPHA_HOVER;
            }
        });

        btn.on('pointerupoutside', () => {
            if (!btn.disabled) {
                btn.icon.alpha = ALPHA_NORMAL;
                btn.arrows.alpha = ALPHA_NORMAL;
            }
        });

        btn.on('pointertap', () => {
            if (btn.disabled) return;

            if (this.autospin.enabled) {
                this.autospin.enabled = false;
                this.autospin.count = 0;
                btn.disable();
            } else {
                this.toggleModal(this.modals.auto);
            }
        });

        // стартовая альфа
        btn.icon.alpha = ALPHA_NORMAL;
        btn.arrows.alpha = ALPHA_NORMAL;

        return btn;
    },

    sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    },

    createReels() {
        const cols = 5;
        const rows = 3;

        const extra = 8;                  // 2 буферных сверху
        const symbolsPerReel = rows + extra;

        const cellW = 246;
        const cellH = 246;
        const gapX = 0;
        const gapY = 0;

        const totalCellH = cellH + gapY;

        this.rows = rows;
        this.cellH = totalCellH;
        this.bounceY = totalCellH * 6.6;

        const reelContainer = this.reelsHolder;
        reelContainer.removeChildren();

        this.game.reels = [];  // в game, как ты просил

        for (let col = 0; col < cols; col++) {
            const reel = new PIXI.Container();
            reel.state = 0;
            reel.stop = 0;
            reel.bounce = false;
            reel.x = col * (cellW + gapX);
            reel.y = 0 - this.cellH * extra;

            // массив слотов внутри барабана
            reel.slots = [];

            // создаём slot-контейнеры
            let rowIndex = -extra;
            for (let i = 0; i < symbolsPerReel; i++) {
                const slot = new PIXI.Container();
                slot.x = 0;
                slot.y = i * totalCellH;

                slot.row = rowIndex;
                rowIndex++;

                reel.addChild(slot);
                reel.slots.push(slot);
            }

            this.game.reels.push(reel);
            reelContainer.addChild(reel);
        }
    },

    fillReels(symbols) {
        if (!symbols || symbols.length !== 15) {
            return;
        }
        const rows = this.rows;
        const extra = 8;
        const cellW = 246;
        const cellH = 246;
        const totalCellH = this.cellH;
        for (let col = 0; col < 5; col++) {
            const reel = this.game.reels[col];
            // === 1. буферные символы ===
            for (let i = 0; i < extra; i++) {
                const symId = this.game.extracomb[col][i];

                const slot = reel.slots[i];
                slot.removeChildren();

                const sprite = this.createSymbolSprite(symId, cellW, cellH, 0, 'extra'+i);
                slot.addChild(sprite);
            }
            // === 2. реальные символы ===
            for (let row = 0; row < rows; row++) {
                const index = row * 5 + col;
                const symId = symbols[index];

                this.game.symbols[row][col] = this.createSymbolSprite(symId, cellW, cellH, 0, 'row'+row);

                const slot = reel.slots[row + extra];
                slot.removeChildren();

                slot.addChild(this.game.symbols[row][col]);
            }
        }
        //this.resizeReels();
    },

    resizeReels() {
        const bounds = this.reelsHolder.getLocalBounds();
        if (bounds.width === 0) return;

        const scale = this.gameWidth / bounds.width;
        this.reelsHolder.scale.set(scale);
        this.reelsHolder.x = 0;
        this.reelsHolder.y = 700;
    },

    async sortReelSlotsInstant() {

        // ждём, пока придёт ответ
        if (this.fastStop) return;
        this.fastStop = true;
        while (!this.game.responsed) {
            await new Promise(r => setTimeout(r, 10));
        }

        for (let i = 0; i < this.game.reels.length; i++) {
            const reel = this.game.reels[i];
            await this.sortOneReelSlotsInstant(reel, i);
            this.reelSpeeds[i] = 0;
        }
    },

    sortOneReelSlotsInstant(reel, num) {
        if (reel.bounce) return;
        if (!this.spinning[num]) return;
        reel.slots.sort((a, b) => a.row - b.row);
        for (let s = 0; s < reel.slots.length; s++) {
            reel.slots[s].y = s * this.cellH;
        }
        reel.y = Math.round(-this.cellH*7.6);
        reel.bounce = true;
        reel.state = 0;
    },

    createSymbolSprite(symId, w, h, y, dbg) {
        const assetNames = this.symbolMap[symId];

        let frames = [];

        // assetNames всегда массив
        for (const name of assetNames) {
            const sheet = PIXI.Assets.get(name);
            if (sheet && sheet.animations && sheet.animations.main) {
                frames = frames.concat(sheet.animations.main);
            }
        }

        // если анимационных кадров нет — fallback на статичную картинку
        if (frames.length === 0) {
            const fallbackName = assetNames[0].replace("anim", "img");
            const texture = PIXI.Assets.get(fallbackName);
            const sp = new PIXI.Sprite(texture ?? PIXI.Texture.WHITE);
/*
            if (dbg !== undefined) {
                const t = new PIXI.Text({ text: String(dbg), style:{ fill:"#ff00ff", fontSize:56, fontWeight:"bold", stroke:"#000", strokeThickness:3 }});
                sp.addChild(t);
            }
*/
            return sp;
        }

        const anim = new PIXI.AnimatedSprite(frames);

        anim.y = y-5;
        anim.x = -5;

/*
        if (dbg !== undefined) {
            const t = new PIXI.Text({ text: String(dbg), style:{ fill:"#ff00ff", fontSize:56, fontWeight:"bold", stroke:"#000", strokeThickness:3 }});
            anim.addChild(t);
        }
*/

        anim.animation = function (enable) {
            if (enable) {
                this.loop = true;
                this.animationSpeed = 0.15;

                if (!this.playing) {
                    this.play();
                }
            } else {
                if (!this.playing) {
                    this.gotoAndStop(0);
                    return;
                }

                this.loop = false;

                this.onComplete = () => {
                    this.gotoAndStop(0);
                    this.onComplete = null;
                };
            }
        };
        return anim;
    },

    startSpin() {
        if (this.game.spinning) return;
        this.game.spinStart = performance.now();
        this.game.responsed = false;
        this.texts.goodluck.text = this.getText("spin");
        this.texts.info.text = "";
        //sdfa
        this.game.spinTicker = () => this.updateSpin();
        this.pixi.ticker.add(this.game.spinTicker);
        this.endWinAnimation();
        this.game.linesCanvas.removeChildren();
        this.data.balanceText.text = this.formatBalance(this.data.balance - this.game.bet);
        this.stopRequested = false;
        this.fastStop = false;
        this.game.spinning = true;
        this.buttons.btnSpin.spinned(true);
        this.buttons.btnSpin.disable();
        this.spinning[0] = true;
        this.spinning[1] = true;
        this.spinning[2] = true;
        this.spinning[3] = true;
        this.spinning[4] = true;
        this.reelSpeeds = [200, 200, 200, 200, 200];
        this.apiSpin();

    },

    updateSpin() {
        const now = performance.now();

        // speed 1: стоп можно инициировать только после ответа API и после 2500мс
        if ( this.stopRequested !== true && this.game.speed === 1 && this.game.responsed === true && (now - this.game.spinStart ) >= 1000 ) {
            this.stopSpin(); // инициируем остановку (дальше она отработает на следующих тиках)
        }
        for (let i = 0; i < this.game.reels.length; i++) {
            if (!this.spinning[i]) continue;
            const reel = this.game.reels[i];
            reel.y += this.reelSpeeds[i];
            if (!reel.bounce) {
                if (reel.y >= -this.cellH) {
                    this.shiftReelSymbols(reel);
                }
                if (this.stopRequested && this.reelSpeeds[i] > 100) {
                    if (reel.stop >= 1) {
                        //this.reelSpeeds[i] -= Math.floor(Math.random() * 3) + 1;
                        this.reelSpeeds[i] -= 3;
                        reel.stop = 0;
                    } else {
                        reel.stop++;
                    }
                }
                if (this.stopRequested && this.reelSpeeds[i] <= 200) {
                    // Ожидание позиции и отбой
                    let canStop = true;
                    if (i > 0) canStop = !this.spinning[i - 1];

                    if (canStop) {
                        this.sortOneReelSlotsInstant(reel, i);
                    }

/*
                    if (reel.state == 0 && reel.y >= -this.bounceY && canStop) {
                        reel.bounce = true;
                    }
*/
                }
            } else {
                const offsetPos = this.cellH * 8 + reel.y;
                //console.log(i, offsetPos)
                //console.log('offset pos:', this.cellH*2, reel.y, i, offsetPos);
                if (offsetPos > 500) this.reelSpeeds[i] = -400;
                else if (offsetPos > 200) this.reelSpeeds[i] = -150;
                else if (offsetPos > 50) this.reelSpeeds[i] = -30;
                else if (offsetPos > 20) this.reelSpeeds[i] = -10;
                else if (offsetPos > 10) this.reelSpeeds[i] = -5;
                else if (offsetPos > 5) this.reelSpeeds[i] = -3;
                else if (offsetPos > 2) this.reelSpeeds[i] = -2;
                else if (offsetPos >= 1) this.reelSpeeds[i] = -1;
                else if (offsetPos == 0) {
                    this.spinning[i] = false;
                    reel.bounce = false;
                    reel.y = -this.cellH*8;
                }
                //this.spinning[i] = false;
            }
        }

        if (this.spinning.every(v => !v)) {
            this.checkSpin();
        }
    },

    shiftReelSymbols(reel) {
        reel.children.forEach((child) => {
            child.y += this.cellH
        });
        const last = reel.removeChildAt(reel.children.length - 1);
        last.y = 0;
        reel.addChildAt(last, 0);
        reel.y -= this.cellH;
        reel.state++;
        if(reel.state > 10) reel.state = 0;
    },

    stopSpin() {
        this.stopRequested = true;
    },

    checkSpin() {
        this.game.spinning = false;
        this.buttons.btnSpin.spinned(false);
        this.buttons.btnSpin.enable();
        this.pixi.ticker.remove(this.game.spinTicker);
        this.data.balanceText.text = this.formatBalance(this.data.balance);
        this.texts.goodluck.text = this.getText("default");
        if (this.game.win > 0) {
            this.data.lastWinText.text = this.formatBalance(this.game.win);

            // Проверяем scatter
            let scatter = null;
            if (this.game.linesMask[0] > 0) {

            }


            // Индексы ненулевых линий
            const activeIndexes = [];
            for (let i = 1; i <= this.game.linesMask.length; i++) {
                if (this.game.linesMask[i] > 0) activeIndexes.push(i);
            }

            // Формируем массив данных по линиям
            const winLines = [];
            for (let idx of activeIndexes) {
                const maskBin = this.dec2Bin(this.game.linesMask[idx]); // "11100" например

                winLines.push({
                    lineNum: this.data.linesMask[idx-1],
                    maskDec: this.game.linesMask[idx],
                    mask: maskBin,
                    value: this.game.linesValue[idx],
                    line: this.data.lines[idx-1]
                });
            }

            for (let wl of winLines) {
                const hlLine = [];
                const hlSymbols = []; // сюда попадут {row, col}
                const mask = wl.mask;     // строка: "11100"
                const line = wl.line;     // массив 3х5, каждый row: [0/1/… columns]
                //console.log(wl.lineNum);
                for (let r = 0; r < 3; r++) {
                    for (let c = 0; c < 5; c++) {
                        if (line[r][c] === 1) {
                            hlLine.push([r, c]);
                        }
                    }
                }
                wl.hlLine = hlLine;
                wl.lineColor = this.lines_colors[wl.lineNum][0];
                wl.coords = this.buildLinePoints(hlLine);

                for (let col = 0; col < 5; col++) {
                    if (mask[col] === "1") {
                        // в этой колонке есть выигрыш → смотрим какая строка активна
                        for (let row = 0; row < 3; row++) {
                            if (line[row][col] === 1) {
                                // значит символ (row, col) выиграл
                                const sym = this.game.symbols[row][col];
                                hlSymbols.push(sym);
                            }
                        }
                    }
                }
                wl.hlSymbols = hlSymbols;
            }
            console.log(winLines);
            this.texts.info.text = this.getText("win") + ": " + this.game.win;
            this.beginWinAnimation(winLines, scatter);
        } else {
            this.testAuto();
        }
    },

    async testAuto() {
        if (!this.autospin.enabled) return;

        if (this.autospin.count > 0) {
            await this.sleep(200);
            this.autospin.count--;
            //console.log("Auto left:", this.autospin.count);
            this.startSpin();
            return;
        }
        this.autospin.enabled = false;
        this.buttons.btnSpin.spinned(false);
        this.buttons.btnAuto.disable();
        return;
    },

    // === Обновление контейнера числа ===
    updateNumberContainer(container, value, scale = 3) {
        const s = String(value);

        // === 1. Находим максимальную высоту цифры (у точек ниже) ===
        // Берём высоту любого цифрового фрейма, например "0"
        const refTex = this.cacheNumberFrames["0"];
        const maxH = refTex ? refTex.height * scale : 0;

        // === 2. Количество спрайтов подгоняем ===
        while (container.children.length > s.length) {
            container.removeChildAt(container.children.length - 1);
        }

        while (container.children.length < s.length) {
            const spr = new PIXI.Sprite();
            spr.anchor.set(0, 0); // якорь сверху-слева
            container.addChild(spr);
        }

        let x = 0;

        // === 3. Заполняем символы ===
        for (let i = 0; i < s.length; i++) {
            const ch = s[i] === "." ? "dot" : s[i];
            const tex = this.cacheNumberFrames[ch];
            if (!tex) continue;

            const spr = container.children[i];
            spr.texture = tex;
            spr.scale.set(scale);

            spr.x = x;

            // === Нижнее выравнивание ===
            // sprite.height может быть меньше maxH (у точки)
            spr.y = maxH - spr.height;

            x += tex.width * scale;
        }
    },

    // === Анимация win числа ===
    animateWin(targetAmount, numberContainer, duration = 5000, scale = 1) {
        const start = performance.now();
        const from = 0;

        // определяем тип выигрыша по кратности к ставке
        const bet = this.game.bet ?? 0;
        const mult = bet ? (targetAmount / bet) : 0;

        let winText = "";
        if (this.winMap) {
            const keys = Object.keys(this.winMap).map(Number).filter(n => !isNaN(n)).sort((a,b) => a - b);
            let picked = null;
            for (const k of keys) {
                if (mult >= k) picked = k;
            }
            if (picked !== null) winText = this.winMap[picked] ?? "";
        }


        // текст над счетчиком
        let winLabel = numberContainer.winLabel;
        if (winText) {
            const sheet = PIXI.Assets.get('winTexts');
            const animName = winText + "Win";
            const frames = (sheet && sheet.animations && sheet.animations[animName]) ? sheet.animations[animName] : [];

            if (!winLabel) {
                winLabel = new PIXI.AnimatedSprite(frames);
                winLabel.anchor.set(0.5); // <-- добавить
                numberContainer.winLabel = winLabel;
                if (numberContainer.parent) numberContainer.parent.addChild(winLabel);
            } else {
                winLabel.textures = frames;
                if (winLabel.anchor) winLabel.anchor.set(0.5); // <-- добавить
            }

            // если кадры в json были rotated:true
            // если кадры в json были rotated:true (атлас собран CCW) — дополнительно разворачиваем на 180°
            if (frames[0] && frames[0].rotate) {
                winLabel.rotation = Math.PI;
            } else {
                winLabel.rotation = 0;
            }

            winLabel.animationSpeed = 0.1; // ~3 раза в секунду
            winLabel.loop = true;
            winLabel.visible = true;
            winLabel.play();

            // grats над текстом большого выигрыша
            let gratsLabel = numberContainer.gratsLabel;
            const gratsFrames = (sheet && sheet.animations && sheet.animations.grats) ? sheet.animations.grats : [];

            if (!gratsLabel) {
                gratsLabel = new PIXI.AnimatedSprite(gratsFrames);
                gratsLabel.anchor.set(0.5);
                gratsLabel.animationSpeed = 0.1;
                gratsLabel.loop = true;
                gratsLabel.play();

                numberContainer.gratsLabel = gratsLabel;
                if (numberContainer.parent) numberContainer.parent.addChild(gratsLabel);
            } else {
                gratsLabel.textures = gratsFrames;
                if (gratsLabel.anchor) gratsLabel.anchor.set(0.5);
                gratsLabel.animationSpeed = 0.1;
                gratsLabel.loop = true;
                gratsLabel.play();
            }

            gratsLabel.visible = true;

            clearTimeout(gratsLabel._hideTimer);
            gratsLabel._hideTimer = setTimeout(() => {
                gratsLabel.visible = false;
            }, duration);


            // скрыть через duration
            clearTimeout(winLabel._hideTimer);
            winLabel._hideTimer = setTimeout(() => {
                winLabel.visible = false;
            }, duration);

        } else if (winLabel) {
            winLabel.visible = false;
            if (numberContainer.gratsLabel) numberContainer.gratsLabel.visible = false;
        }

        const easeOut = t => 1 - Math.pow(1 - t, 3);
        const frame = (now) => {
            const progress = Math.min((now - start) / duration, 1);
            const eased = easeOut(progress);
            const raw = from + (targetAmount - from) * eased;
            // формируем строку с 2 знаками — важно!
            const current = raw.toFixed(2);
            this.updateNumberContainer(numberContainer, current, scale);

            const baseX = this.gameFieldWidth / 2;
            const baseY = this.gameFieldHeight / 2;

            numberContainer.x = baseX - numberContainer.width / 2;

            let offsetY = 0;
            if (winText && winLabel && winLabel.visible !== false) {
                winLabel.visible = true;
                winLabel.x = baseX
                const margin = 10;
                offsetY = (winLabel.height / 2) + margin;
                winLabel.y = baseY - (numberContainer.height / 2);

                const gratsLabel = numberContainer.gratsLabel;
                if (gratsLabel && gratsLabel.visible !== false) {
                    gratsLabel.x = baseX;
                    gratsLabel.y = winLabel.y - winLabel.height / 2 - gratsLabel.height / 2 - margin;
                }
            }

            numberContainer.y = baseY - numberContainer.height / 2 + offsetY;

            if (progress < 1) {
                requestAnimationFrame(frame);
            }
        };
        requestAnimationFrame(frame);
    },

    async apiRequest(action, params) {
        let base = "dinit.php";
        let q = {
            action: action,
            gamename: this.gameNameApi
        };
        for (let k in params) {
            q[k] = params[k];
        }
        var query = [];
        for (var key in q) {
            query.push(encodeURIComponent(key) + "=" + encodeURIComponent(q[key]));
        }
        // Выполняем запрос
        return await fetch(base + "?" + query.join("&"), {
            method: "GET",
/*
            headers: {
                "token": "demo",
                "tokenuser": "demo",
                "X-Requested-With": "XMLHttpRequest"
            }
*/


            headers: {
                "token": "683ae40d-25b9-bc80-bda6-696f99ea74c3",
                "tokenuser": "5569752",
                "X-Requested-With": "XMLHttpRequest"
            }

        }).then(function (r) {
            if (!r.ok){
                throw new Error("HTTP " + r.status);

            }
            //console.log(r.text());
            return r.json();
        });
    },

    async apiStart() {
        var response = await this.apiRequest("start", {"agtunique": this.fingergrint});
        this.data.balance = this.formatBalance(response.balance);
        this.data.bets = response.bets;
        this.data.currency = response.currency;
        this.data.bets = response.full_bets;

        const linesKeys = Object.keys(response.full_bets);
        if (!response.full_bets?.[this.game.lines]?.includes(this.game.bet)) {
            this.game.lines = Number(linesKeys[0]);
            this.game.bet = response.full_bets[linesKeys[0]][0];
            this.lsSet("game", "lines", this.game.lines);
            this.lsSet("game", "bet", this.game.bet);
        }
        this.data.lines = response.lines;
        this.data.linesMask = response.linesMask;
        //this.lang = response.lang;
        this.langs = response.langs;
        this.mult = 2;
        console.log("Loaded start()");
    },

    async apiRestore() {
        var response = await this.apiRequest("restore", {"agtunique": this.fingergrint});
        this.data.balance = this.formatBalance(response.balance);
        this.game.comb = response.comb;
        this.game.extracomb = response.extracomb;
        console.log("Loaded restore()");
        console.log(response.comb);
    },

    async apiSpin() {
        var response = await this.apiRequest("spin", {"li": this.game.lines, "amount": this.game.bet});
        console.log('Jackpot:', response.jpwin);
        this.data.balance = this.formatBalance(parseFloat(response.balance) + parseFloat(response.win) );
        this.game.comb = response.comb;
        this.game.extracomb = response.extracomb;
        this.game.linesMaskDec = response.linesMask;
        //this.game.linesMask = this.dec2BinArr(response.linesMask);
        this.game.linesMask = response.linesMask;
        if (response.win > 0) console.log(response.linesMask);
        this.game.linesValue = response.linesValue;
        this.game.win = response.win;

        //this.data.lastWinText.text = response.linesValue.length;
        if (response.win > 0) this.data.lastWinText.text = response.win;
        //console.log("Loaded spin()");
        //console.log(response.balance);
        this.fillReels(response.comb);
        this.game.responsed = true;
        if (this.game.speed == 3) {
            this.sortReelSlotsInstant();
        }
        if (this.game.speed >= 2) {
            this.stopSpin();
        }
    },

    dec2Bin(n) {
        let b = Number(n).toString(2);   // преобразуем в двоичное
        if (b.length > 5) {
            b = b.slice(-5);             // обрезаем слева
        } else {
            b = b.padStart(5, "0");      // добавляем нули слева
        }
        return b;
    },

    dec2BinArr(arr) {
        return arr.map(n => this.dec2Bin(n));
    },

    formatBalance(value) {
        const n = Number(value);
        return n.toFixed(this.mult);
    },

    openModal(modal) {
        //this.modalLayer.addChild(modal);
        modal.visible = true;
    },

    closeModal(modal) {
        //this.modalLayer.removeChild(modal);
        modal.visible = false;
    },

    toggleModal(modal) {
        if(modal.visible) {
            this.closeModal(modal);
        } else {
            this.openModal(modal);
        }
    },

    beginWinAnimation(winLines, scatter) {
        this.game.winAnimation = true;
        this.openModal(this.modals.wins);
        this.animateWin(this.game.win, this.winNumber, 5000, 0.8);
        this.showWinningLines(winLines, scatter);
    },

    endWinAnimation() {
        this.game.winAnimation = false;
        this.closeModal(this.modals.wins);
    },

    resize(full = true) {
        const ww = window.innerWidth;
        const wh = window.innerHeight;
        const gw = this.gameWidth;

        // НОВОЕ: вычисляем логическую высоту из пропорций экрана
        let gh = Math.max(
            this.minGameHeight,
            gw * (wh / ww)
        );

        // НОВОЕ: отсекаем заведомо неправильные форматы (слишком "широкие")
        if ((ww / wh) > (this.gameWidth / this.minGameHeight)) {
            gh = 2460;
        }

        this.gameHeight = gh;


        const scale = Math.min(ww / gw, wh / gh);

        // 1) Ресайзим рендерер под реальный размер в CSS-пикселях
        this.pixi.renderer.resize(
            ww, wh
        );

        // 2) Скейлим всю сцену (единая система координат)
        this.gameRoot.scale.set(scale);
        this.gameRoot.x = ww / 2;
        this.gameRoot.y = wh / 2;
        this.gameRoot.pivot.set(gw / 2, gh / 2);
        if (full) {
            this.resizeBg();
            this.resizeGameScreen();
        }
    },

    drawSmoothLine(points, color = "gold", width = 10) {
        const g =  new PIXI.Container();
        g.addChild(this.drawSingleLine(points, {width: 24, color:color, alpha: 0.25}));
        g.addChild(this.drawSingleLine(points, {width: 18, color:color, alpha: 1}));
        g.addChild(this.drawSingleLine(points, {width: 12, color:color, alpha: 0.85}));
        g.addChild(this.drawSingleLine(points, {width: 4, color:"#fff", alpha: 0.6}, 3));
        return g;
    },

    drawSingleLine(points, stroke = {}, offset = 0) {
        const g = new PIXI.Graphics();
        g.moveTo(points[0].x, points[0].y-offset);
        for (let i = 0; i < points.length - 1; i++) {
            const p1 = points[i];
            const p2 = points[i + 1];
            const dx = (p2.x - p1.x) * 0.45;
            const cp1x = p1.x + dx;
            const cp1y = p1.y-offset;
            const cp2x = p2.x - dx;
            const cp2y = p2.y-offset;
            g.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p2.x, p2.y-offset);
        }
        g.stroke(stroke);
        return g;
    },

    buildLinePoints(hlLine) {
        const coord = this.data.lineCoord;

        // === ДОБАВЛЕННАЯ СТРОКА: сортировка по col ===
        const sorted = [...hlLine].sort((a, b) => a[1] - b[1]);

        const points = [];

        // первая точка линии
        const firstRow = sorted[0][0];
        const firstY = coord[firstRow];
        points.push({ x: coord.begin, y: firstY });

        // точки по символам
        for (const [row, col] of sorted) {
            const x = coord[col];
            const y = coord[row];
            points.push({ x, y });
        }

        // последняя точка линии
        const lastRow = sorted[sorted.length - 1][0];
        const lastY = coord[lastRow];
        points.push({ x: coord.end, y: lastY });

        return points;
    },

    showWinningLines(winLines) {
        const CONTAINER_WIDTH  = 246 * 5 + 2;
        const CONTAINER_HEIGHT = 246 * 3 + 2;

        const MASK_WIDTH_MULTIPLIER = 3;
        const MASK_SHIFT_MULTIPLIER = 4;

        const ANIMATION_DURATION = 2500; // мс
        const PAUSE_BETWEEN_LINES = 30; // мс

        const parent = this.game.linesCanvas;

        let currentIndex = 0;


        // === ПРОЛОГ: все линии сразу под одной маской (2 прохода)
        const runIntroAnimation = (onComplete) => {
            const introContainer = new PIXI.Container();
            introContainer.width  = CONTAINER_WIDTH;
            introContainer.height = CONTAINER_HEIGHT;

            parent.addChild(introContainer);

            // маска
            const introMask = new PIXI.Graphics();
            introMask.rect(
                0,
                0,
                CONTAINER_WIDTH * MASK_WIDTH_MULTIPLIER,
                CONTAINER_HEIGHT
            ).fill(0xffffff);

            introMask.x = -CONTAINER_WIDTH * MASK_SHIFT_MULTIPLIER;
            introContainer.addChild(introMask);
            introContainer.mask = introMask;

            // все линии в одном контейнере
            for (const line of winLines) {
                const g = this.drawSmoothLine(
                    line.coords,
                    line.lineColor,
                    10
                );
                introContainer.addChild(g);
            }

            const startX = -CONTAINER_WIDTH * MASK_SHIFT_MULTIPLIER;
            const endX   =  CONTAINER_WIDTH * MASK_SHIFT_MULTIPLIER;

            let pass = 0;

            const animatePass = () => {
                const startTime = performance.now();

                const step = () => {
                    let t = (performance.now() - startTime) / INTRO_PASS_DURATION;
                    if (t > 1) t = 1;

                    introMask.x = startX + (endX - startX) * t;

                    if (t < 1) {
                        requestAnimationFrame(step);
                    } else {
                        pass++;
                        if (pass < 2) {
                            introMask.x = startX;
                            requestAnimationFrame(animatePass);
                        } else {
                            parent.removeChild(introContainer);
                            introContainer.destroy({ children: true });

                            // очистка контейнера выигрыша
                            if (this.winNumber) {
                                this.winNumber.removeChildren();
                            }
                            onComplete();
                        }
                    }
                };

                requestAnimationFrame(step);
            };

            const INTRO_TOTAL_DURATION = 5000;
            const INTRO_PASS_DURATION  = INTRO_TOTAL_DURATION / 2;

            animatePass();
        };

        const showNextLine = () => {

            this.texts.info.text = "";

            if (currentIndex >= winLines.length) {
                currentIndex = 0;
            }

            if (!this.game.winAnimation) return;

            const lineData = winLines[currentIndex];
            currentIndex++;

            this.texts.info.text = this.getText("line") + " " + lineData.lineNum + " - " + this.getText("win") + " " + Number(lineData.value).toFixed(2);;


            // === 1. Контейнер линии
            const lineContainer = new PIXI.Container();
            lineContainer.width  = CONTAINER_WIDTH;
            lineContainer.height = CONTAINER_HEIGHT;

            parent.addChild(lineContainer);

            // === 2. Маска (400% ширины)
            const mask = new PIXI.Graphics();
            mask.rect(
                0,
                0,
                CONTAINER_WIDTH * MASK_WIDTH_MULTIPLIER,
                CONTAINER_HEIGHT
            ).fill(0xffffff);

            mask.x = -CONTAINER_WIDTH * MASK_SHIFT_MULTIPLIER;
            mask.y = 0;

            lineContainer.addChild(mask);
            lineContainer.mask = mask;

            // === 3. Отрисовка линии
            const lineGraphic = this.drawSmoothLine(
                lineData.coords,
                lineData.lineColor,
                10
            );

            lineContainer.addChild(lineGraphic);

            // ВКЛ: включаем анимацию символов только этой линии
            if (lineData.hlSymbols && Array.isArray(lineData.hlSymbols)) {
                for (const sym of lineData.hlSymbols) {
                    //const sym = this.game.symbols?.[row]?.[col];
                    //console.log(sym);
                    if (sym && typeof sym.animation === "function") {
                        sym.animation(true);
                    }
                }
            }

            // === 4. Анимация маски
            const startX = -CONTAINER_WIDTH * MASK_SHIFT_MULTIPLIER;
            const endX   =  CONTAINER_WIDTH * MASK_SHIFT_MULTIPLIER;

            const duration  = ANIMATION_DURATION;
            const startTime = performance.now();

            function animateMask() {
                const now = performance.now();
                let t = (now - startTime) / duration;

                if (t > 1) t = 1;

                mask.x = startX + (endX - startX) * t;

                if (t < 1) {
                    requestAnimationFrame(animateMask);
                } else {
                    parent.removeChild(lineContainer);
                    lineContainer.destroy({ children: true });

                    // ВЫКЛ: включаем анимацию символов только этой линии
                    if (lineData.hlSymbols && Array.isArray(lineData.hlSymbols)) {
                        for (const sym of lineData.hlSymbols) {
                            //const sym = this.game.symbols?.[row]?.[col];
                            //console.log(sym);
                            if (sym && typeof sym.animation === "function") {
                                sym.animation(false);
                            }
                        }
                    }

                    setTimeout(showNextLine, PAUSE_BETWEEN_LINES);
                }
            }
            requestAnimationFrame(animateMask);
        };
        runIntroAnimation(() => {
            if(this.autospin.enabled) {
                this.winAnimation = false;
                this.testAuto();
            } else {
                showNextLine();
            }
        });
    },

    getText(code) {
        return this.langs[this.lang][code];
    },

    lsSet(group, key, value) {
        const path = `games.${this.gameName}.${group}.${key}`;
        localStorage.setItem(path, JSON.stringify(value));
    },

    lsGet(group, key, def = null) {
        const path = `games.${this.gameName}.${group}.${key}`;
        const v = localStorage.getItem(path);
        return v === null ? def : JSON.parse(v);
    },

    lsRemove(group, key) {
        const path = `games.${this.gameName}.${group}.${key}`;
        localStorage.removeItem(path);
    },

    reloadLang() {
        this.texts.goodluck.text = this.getText("default");
        this.texts.balanceTitle.text = this.getText("balance") + " (" + this.data.currency + ")";
        this.texts.linesTitle.text = this.getText("lines");
        this.texts.betsTitle.text = this.getText("bet");
        this.texts.lastWinTitle.text = this.getText("last_win");
    },





    // === FULLSCREEN (mobile-first) ===
    initFullscreen() {
        // Контейнер, внутри которого живёт canvas Pixi (у вас: div#root)
        this.fullscreenRootEl = document.getElementById('root');

        // если root не найден — ничего не ломаем
        if (!this.fullscreenRootEl) {
            this.fullscreenRootEl = document.documentElement;
        }

        // слушатели изменений native fullscreen (android/desktop)
        document.addEventListener('fullscreenchange', () => {
            this.onFullscreenChanged();
        });

        document.addEventListener('webkitfullscreenchange', () => {
            this.onFullscreenChanged();
        });

        // на мобилках смена ориентации/высоты viewport тоже важна
        window.addEventListener('resize', () => {
            // не спамим лишним full-перелэйаутом, но ваш resize должен отработать
            this.resize(true);
            this.updateFullscreenButtonState();
        });

        this.updateFullscreenButtonState();
    },

    isIOS() {
        // достаточно надёжно для практики
        return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
    },

    canNativeFullscreen(el) {
        return !!(el && (el.requestFullscreen || el.webkitRequestFullscreen));
    },

    isNativeFullscreen() {
        return !!(document.fullscreenElement || document.webkitFullscreenElement);
    },

    isPseudoFullscreen() {
        const el = this.fullscreenRootEl;
        return !!(el && el.classList && el.classList.contains('app-fullscreen'));
    },

    enterPseudoFullscreen() {
        const el = this.fullscreenRootEl;
        if (!el || !el.classList) return;
        el.classList.add('app-fullscreen');
    },

    exitPseudoFullscreen() {
        const el = this.fullscreenRootEl;
        if (!el || !el.classList) return;
        el.classList.remove('app-fullscreen');
    },

    enterNativeFullscreen() {
        const el = this.fullscreenRootEl;
        if (!el) return;

        if (el.requestFullscreen) {
            return el.requestFullscreen();
        }
        if (el.webkitRequestFullscreen) {
            return el.webkitRequestFullscreen();
        }
    },

    exitNativeFullscreen() {
        if (document.exitFullscreen) {
            return document.exitFullscreen();
        }
        if (document.webkitExitFullscreen) {
            return document.webkitExitFullscreen();
        }
    },

    isFullscreenOn() {
        // “включено” = native fullscreen или pseudo fullscreen
        return this.isNativeFullscreen() || this.isPseudoFullscreen();
    },

    toggleFullscreen() {
        // iOS: только pseudo
        if (this.isIOS()) {
            if (!this.isPseudoFullscreen()) {
                this.enterPseudoFullscreen();
            } else {
                this.exitPseudoFullscreen();
            }

            // после смены класса надо дать браузеру применить layout
            setTimeout(() => {
                this.resize(true);
                this.updateFullscreenButtonState();
            }, 0);

            return;
        }

        // не iOS: пробуем native, иначе fallback на pseudo
        if (this.canNativeFullscreen(this.fullscreenRootEl)) {
            if (!this.isNativeFullscreen()) {
                Promise.resolve(this.enterNativeFullscreen()).finally(() => {
                    // подстраховка (основное — fullscreenchange)
                    setTimeout(() => {
                        this.resize(true);
                        this.updateFullscreenButtonState();
                    }, 0);
                });
            } else {
                Promise.resolve(this.exitNativeFullscreen()).finally(() => {
                    setTimeout(() => {
                        this.resize(true);
                        this.updateFullscreenButtonState();
                    }, 0);
                });
            }
            return;
        }

        // fallback: pseudo
        if (!this.isPseudoFullscreen()) {
            this.enterPseudoFullscreen();
        } else {
            this.exitPseudoFullscreen();
        }

        setTimeout(() => {
            this.resize(true);
            this.updateFullscreenButtonState();
        }, 0);
    },

    onFullscreenChanged() {
        // вызывается на fullscreenchange/webkitfullscreenchange
        this.resize(true);
        this.updateFullscreenButtonState();
    },

    updateFullscreenButtonState() {
        // ВАЖНО: здесь я не угадываю вашу структуру кнопки.
        // Но у вас подход такой: btn.disable/enable + alpha + иконки.
        // Поэтому делаю максимально безопасно: если кнопка есть — обновим её визуально.
        const btn = this.btns ? this.btns.fullscreen : null;
        if (!btn) return;

        const on = this.isFullscreenOn();

        // минимально-визуально: альфа/или флаг состояния
        btn.isOn = on;

        // Если у кнопки есть методы enable/disable или кастомная подсветка — не ломаем.
        // Просто подправим alpha, если она у вас используется.
        if (typeof btn.alpha === 'number') {
            btn.alpha = on ? 1 : 0.85;
        }

        // Если у кнопки есть иконки двух состояний — вы потом сюда подцепите.
        // Например:
        // if (btn.iconOn) btn.iconOn.visible = on;
        // if (btn.iconOff) btn.iconOff.visible = !on;
    }


};

window.addEventListener("DOMContentLoaded", () => {
    window.app.init();
});
